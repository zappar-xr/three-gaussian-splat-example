{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,IIEM,ECMF,EACA,EAkFA,E,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,A,C,E,E,Q,A,E,Q,S,C,C,C,E,E,E,O,C,S,I,G,E,E,O,C,O,I,G,E,E,O,C,W,I,EH3FJ;;;;CAIG,EAaU,IAAA,EAAc,OAAO,iBACrB,EAAiB,OAAO,oBACxB,EAAe,OAAO,wBACtB,EAAY,OAAO,qBAE1B,EAAc,OAAO,kBAuJrB,EAAW,AAAC,GACf,AAAe,UAAf,OAAO,GAAoB,AAAQ,OAAR,GAAiB,AAAe,YAAf,OAAO,EA+FzC,EAAmB,IAAI,IAGlC,CACA,CAAC,QAjEgE,CACjE,UAAW,AAAC,GACV,EAAS,IAAS,CAAmB,CAAC,EAAY,CACpD,UAAU,CAAG,EACX,GAAM,CAAA,MAAE,CAAK,CAAA,MAAE,CAAK,CAAE,CAAG,IAAI,eAE7B,OADA,EAAO,EAAK,GACL,CAAC,EAAO,CAAC,EAAM,CAAC,AACxB,EACD,YAAA,AAAY,IACV,EAAK,KAAK,GACH,EAAK,GAEf,EAqDgC,CAC/B,CAAC,QAtCC,CACF,UAAW,AAAC,GACV,EAAS,IAAU,KAAe,EACpC,UAAA,CAAU,CAAA,MAAE,CAAK,CAAE,GAcV,CAZH,aAAiB,MACN,CACX,QAAS,CAAA,EACT,MAAO,CACL,QAAS,EAAM,OAAO,CACtB,KAAM,EAAM,IAAI,CAChB,MAAO,EAAM,KAAK,AACnB,CACF,EAEY,CAAE,QAAS,CAAA,EAAO,MAAA,CAAK,EAElB,EAAE,CAAC,CAEzB,YAAY,CAAU,EACpB,GAAI,EAAW,OAAO,CACpB,MAAM,OAAO,MAAM,CACjB,AAAI,MAAM,EAAW,KAAK,CAAC,OAAO,EAClC,EAAW,KAAK,CAGpB,OAAM,EAAW,KAAK,AA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","sources":["<anon>","node_modules/comlink/dist/esm/comlink.mjs","node_modules/comlink/src/comlink.ts","node_modules/@zappar/three-gaussian-splat/lib/cpp-sorter/worker.js","node_modules/@zappar/three-gaussian-splat/lib/cpp-sorter/sort.js","node_modules/process/browser.js","node_modules/@parcel/runtime-js/lib/runtime-401fb06aea8b84d2.js","node_modules/@zappar/three-gaussian-splat/lib/cpp-sorter/BufferPool.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire423e\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire423e\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"dLq9J\", function(module, exports) {\n\n$parcel$export(module.exports, \"expose\", () => $0e112480d1414235$export$9b7f6e342a8cbd38);\n$parcel$export(module.exports, \"wrap\", () => $0e112480d1414235$export$4997ffc0176396a6);\n$parcel$export(module.exports, \"transfer\", () => $0e112480d1414235$export$c9b234447cf4ef7c);\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const $0e112480d1414235$export$be5234c0b764b6e0 = Symbol(\"Comlink.proxy\");\nconst $0e112480d1414235$export$39fb953702b7fcd7 = Symbol(\"Comlink.endpoint\");\nconst $0e112480d1414235$export$89981d4b8d9f48aa = Symbol(\"Comlink.releaseProxy\");\nconst $0e112480d1414235$export$ddc31dfe7c269837 = Symbol(\"Comlink.finalizer\");\nconst $0e112480d1414235$var$throwMarker = Symbol(\"Comlink.thrown\");\nconst $0e112480d1414235$var$isObject = (val)=>typeof val === \"object\" && val !== null || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */ const $0e112480d1414235$var$proxyTransferHandler = {\n    canHandle: (val)=>$0e112480d1414235$var$isObject(val) && val[$0e112480d1414235$export$be5234c0b764b6e0],\n    serialize (obj) {\n        const { port1: port1, port2: port2 } = new MessageChannel();\n        $0e112480d1414235$export$9b7f6e342a8cbd38(obj, port1);\n        return [\n            port2,\n            [\n                port2\n            ]\n        ];\n    },\n    deserialize (port) {\n        port.start();\n        return $0e112480d1414235$export$4997ffc0176396a6(port);\n    }\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */ const $0e112480d1414235$var$throwTransferHandler = {\n    canHandle: (value)=>$0e112480d1414235$var$isObject(value) && $0e112480d1414235$var$throwMarker in value,\n    serialize ({ value: value }) {\n        let serialized;\n        if (value instanceof Error) serialized = {\n            isError: true,\n            value: {\n                message: value.message,\n                name: value.name,\n                stack: value.stack\n            }\n        };\n        else serialized = {\n            isError: false,\n            value: value\n        };\n        return [\n            serialized,\n            []\n        ];\n    },\n    deserialize (serialized) {\n        if (serialized.isError) throw Object.assign(new Error(serialized.value.message), serialized.value);\n        throw serialized.value;\n    }\n};\n/**\n * Allows customizing the serialization of certain values.\n */ const $0e112480d1414235$export$ab8f1c00731ee83e = new Map([\n    [\n        \"proxy\",\n        $0e112480d1414235$var$proxyTransferHandler\n    ],\n    [\n        \"throw\",\n        $0e112480d1414235$var$throwTransferHandler\n    ]\n]);\nfunction $0e112480d1414235$var$isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins){\n        if (origin === allowedOrigin || allowedOrigin === \"*\") return true;\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) return true;\n    }\n    return false;\n}\nfunction $0e112480d1414235$export$9b7f6e342a8cbd38(obj, ep = globalThis, allowedOrigins = [\n    \"*\"\n]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) return;\n        if (!$0e112480d1414235$var$isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id: id, type: type, path: path } = Object.assign({\n            path: []\n        }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map($0e112480d1414235$var$fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop)=>obj[prop], obj);\n            const rawValue = path.reduce((obj, prop)=>obj[prop], obj);\n            switch(type){\n                case \"GET\" /* MessageType.GET */ :\n                    returnValue = rawValue;\n                    break;\n                case \"SET\" /* MessageType.SET */ :\n                    parent[path.slice(-1)[0]] = $0e112480d1414235$var$fromWireValue(ev.data.value);\n                    returnValue = true;\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */ :\n                    returnValue = rawValue.apply(parent, argumentList);\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */ :\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = $0e112480d1414235$export$923f96dd5afa9ce6(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */ :\n                    {\n                        const { port1: port1, port2: port2 } = new MessageChannel();\n                        $0e112480d1414235$export$9b7f6e342a8cbd38(obj, port2);\n                        returnValue = $0e112480d1414235$export$c9b234447cf4ef7c(port1, [\n                            port1\n                        ]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */ :\n                    returnValue = undefined;\n                    break;\n                default:\n                    return;\n            }\n        } catch (value) {\n            returnValue = {\n                value: value,\n                [$0e112480d1414235$var$throwMarker]: 0\n            };\n        }\n        Promise.resolve(returnValue).catch((value)=>{\n            return {\n                value: value,\n                [$0e112480d1414235$var$throwMarker]: 0\n            };\n        }).then((returnValue)=>{\n            const [wireValue, transferables] = $0e112480d1414235$var$toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), {\n                id: id\n            }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */ ) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                $0e112480d1414235$var$closeEndPoint(ep);\n                if ($0e112480d1414235$export$ddc31dfe7c269837 in obj && typeof obj[$0e112480d1414235$export$ddc31dfe7c269837] === \"function\") obj[$0e112480d1414235$export$ddc31dfe7c269837]();\n            }\n        }).catch((error)=>{\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = $0e112480d1414235$var$toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [$0e112480d1414235$var$throwMarker]: 0\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), {\n                id: id\n            }), transferables);\n        });\n    });\n    if (ep.start) ep.start();\n}\nfunction $0e112480d1414235$var$isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction $0e112480d1414235$var$closeEndPoint(endpoint) {\n    if ($0e112480d1414235$var$isMessagePort(endpoint)) endpoint.close();\n}\nfunction $0e112480d1414235$export$4997ffc0176396a6(ep, target) {\n    return $0e112480d1414235$var$createProxy(ep, [], target);\n}\nfunction $0e112480d1414235$var$throwIfProxyReleased(isReleased) {\n    if (isReleased) throw new Error(\"Proxy has been released and is not useable\");\n}\nfunction $0e112480d1414235$var$releaseEndpoint(ep) {\n    return $0e112480d1414235$var$requestResponseMessage(ep, {\n        type: \"RELEASE\" /* MessageType.RELEASE */ \n    }).then(()=>{\n        $0e112480d1414235$var$closeEndPoint(ep);\n    });\n}\nconst $0e112480d1414235$var$proxyCounter = new WeakMap();\nconst $0e112480d1414235$var$proxyFinalizers = \"FinalizationRegistry\" in globalThis && new FinalizationRegistry((ep)=>{\n    const newCount = ($0e112480d1414235$var$proxyCounter.get(ep) || 0) - 1;\n    $0e112480d1414235$var$proxyCounter.set(ep, newCount);\n    if (newCount === 0) $0e112480d1414235$var$releaseEndpoint(ep);\n});\nfunction $0e112480d1414235$var$registerProxy(proxy, ep) {\n    const newCount = ($0e112480d1414235$var$proxyCounter.get(ep) || 0) + 1;\n    $0e112480d1414235$var$proxyCounter.set(ep, newCount);\n    if ($0e112480d1414235$var$proxyFinalizers) $0e112480d1414235$var$proxyFinalizers.register(proxy, ep, proxy);\n}\nfunction $0e112480d1414235$var$unregisterProxy(proxy) {\n    if ($0e112480d1414235$var$proxyFinalizers) $0e112480d1414235$var$proxyFinalizers.unregister(proxy);\n}\nfunction $0e112480d1414235$var$createProxy(ep, path = [], target = function() {}) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get (_target, prop) {\n            $0e112480d1414235$var$throwIfProxyReleased(isProxyReleased);\n            if (prop === $0e112480d1414235$export$89981d4b8d9f48aa) return ()=>{\n                $0e112480d1414235$var$unregisterProxy(proxy);\n                $0e112480d1414235$var$releaseEndpoint(ep);\n                isProxyReleased = true;\n            };\n            if (prop === \"then\") {\n                if (path.length === 0) return {\n                    then: ()=>proxy\n                };\n                const r = $0e112480d1414235$var$requestResponseMessage(ep, {\n                    type: \"GET\" /* MessageType.GET */ ,\n                    path: path.map((p)=>p.toString())\n                }).then($0e112480d1414235$var$fromWireValue);\n                return r.then.bind(r);\n            }\n            return $0e112480d1414235$var$createProxy(ep, [\n                ...path,\n                prop\n            ]);\n        },\n        set (_target, prop, rawValue) {\n            $0e112480d1414235$var$throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = $0e112480d1414235$var$toWireValue(rawValue);\n            return $0e112480d1414235$var$requestResponseMessage(ep, {\n                type: \"SET\" /* MessageType.SET */ ,\n                path: [\n                    ...path,\n                    prop\n                ].map((p)=>p.toString()),\n                value: value\n            }, transferables).then($0e112480d1414235$var$fromWireValue);\n        },\n        apply (_target, _thisArg, rawArgumentList) {\n            $0e112480d1414235$var$throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === $0e112480d1414235$export$39fb953702b7fcd7) return $0e112480d1414235$var$requestResponseMessage(ep, {\n                type: \"ENDPOINT\" /* MessageType.ENDPOINT */ \n            }).then($0e112480d1414235$var$fromWireValue);\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") return $0e112480d1414235$var$createProxy(ep, path.slice(0, -1));\n            const [argumentList, transferables] = $0e112480d1414235$var$processArguments(rawArgumentList);\n            return $0e112480d1414235$var$requestResponseMessage(ep, {\n                type: \"APPLY\" /* MessageType.APPLY */ ,\n                path: path.map((p)=>p.toString()),\n                argumentList: argumentList\n            }, transferables).then($0e112480d1414235$var$fromWireValue);\n        },\n        construct (_target, rawArgumentList) {\n            $0e112480d1414235$var$throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = $0e112480d1414235$var$processArguments(rawArgumentList);\n            return $0e112480d1414235$var$requestResponseMessage(ep, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */ ,\n                path: path.map((p)=>p.toString()),\n                argumentList: argumentList\n            }, transferables).then($0e112480d1414235$var$fromWireValue);\n        }\n    });\n    $0e112480d1414235$var$registerProxy(proxy, ep);\n    return proxy;\n}\nfunction $0e112480d1414235$var$myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction $0e112480d1414235$var$processArguments(argumentList) {\n    const processed = argumentList.map($0e112480d1414235$var$toWireValue);\n    return [\n        processed.map((v)=>v[0]),\n        $0e112480d1414235$var$myFlat(processed.map((v)=>v[1]))\n    ];\n}\nconst $0e112480d1414235$var$transferCache = new WeakMap();\nfunction $0e112480d1414235$export$c9b234447cf4ef7c(obj, transfers) {\n    $0e112480d1414235$var$transferCache.set(obj, transfers);\n    return obj;\n}\nfunction $0e112480d1414235$export$923f96dd5afa9ce6(obj) {\n    return Object.assign(obj, {\n        [$0e112480d1414235$export$be5234c0b764b6e0]: true\n    });\n}\nfunction $0e112480d1414235$export$f2c03fb5a6c19546(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables)=>w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context)\n    };\n}\nfunction $0e112480d1414235$var$toWireValue(value) {\n    for (const [name, handler] of $0e112480d1414235$export$ab8f1c00731ee83e)if (handler.canHandle(value)) {\n        const [serializedValue, transferables] = handler.serialize(value);\n        return [\n            {\n                type: \"HANDLER\" /* WireValueType.HANDLER */ ,\n                name: name,\n                value: serializedValue\n            },\n            transferables\n        ];\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */ ,\n            value: value\n        },\n        $0e112480d1414235$var$transferCache.get(value) || []\n    ];\n}\nfunction $0e112480d1414235$var$fromWireValue(value) {\n    switch(value.type){\n        case \"HANDLER\" /* WireValueType.HANDLER */ :\n            return $0e112480d1414235$export$ab8f1c00731ee83e.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */ :\n            return value.value;\n    }\n}\nfunction $0e112480d1414235$var$requestResponseMessage(ep, msg, transfers) {\n    return new Promise((resolve)=>{\n        const id = $0e112480d1414235$var$generateUUID();\n        ep.addEventListener(\"message\", function l(ev) {\n            if (!ev.data || !ev.data.id || ev.data.id !== id) return;\n            ep.removeEventListener(\"message\", l);\n            resolve(ev.data);\n        });\n        if (ep.start) ep.start();\n        ep.postMessage(Object.assign({\n            id: id\n        }, msg), transfers);\n    });\n}\nfunction $0e112480d1414235$var$generateUUID() {\n    return new Array(4).fill(0).map(()=>Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join(\"-\");\n}\n\n});\n\nvar $b2637d91d9747a63$exports = {};\n\n$parcel$export($b2637d91d9747a63$exports, \"WasmSorter\", () => $b2637d91d9747a63$export$2c307b8f11fd7777);\n/// <reference types=\"emscripten\"/>\n\nvar $dLq9J = parcelRequire(\"dLq9J\");\nvar $cfae44f0dfdf62c0$exports = {};\n// shim for using process in browser\nvar $cfae44f0dfdf62c0$var$process = $cfae44f0dfdf62c0$exports = {};\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\nvar $cfae44f0dfdf62c0$var$cachedSetTimeout;\nvar $cfae44f0dfdf62c0$var$cachedClearTimeout;\nfunction $cfae44f0dfdf62c0$var$defaultSetTimout() {\n    throw new Error(\"setTimeout has not been defined\");\n}\nfunction $cfae44f0dfdf62c0$var$defaultClearTimeout() {\n    throw new Error(\"clearTimeout has not been defined\");\n}\n(function() {\n    try {\n        if (typeof setTimeout === \"function\") $cfae44f0dfdf62c0$var$cachedSetTimeout = setTimeout;\n        else $cfae44f0dfdf62c0$var$cachedSetTimeout = $cfae44f0dfdf62c0$var$defaultSetTimout;\n    } catch (e) {\n        $cfae44f0dfdf62c0$var$cachedSetTimeout = $cfae44f0dfdf62c0$var$defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === \"function\") $cfae44f0dfdf62c0$var$cachedClearTimeout = clearTimeout;\n        else $cfae44f0dfdf62c0$var$cachedClearTimeout = $cfae44f0dfdf62c0$var$defaultClearTimeout;\n    } catch (e) {\n        $cfae44f0dfdf62c0$var$cachedClearTimeout = $cfae44f0dfdf62c0$var$defaultClearTimeout;\n    }\n})();\nfunction $cfae44f0dfdf62c0$var$runTimeout(fun) {\n    if ($cfae44f0dfdf62c0$var$cachedSetTimeout === setTimeout) //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n    // if setTimeout wasn't available but was latter defined\n    if (($cfae44f0dfdf62c0$var$cachedSetTimeout === $cfae44f0dfdf62c0$var$defaultSetTimout || !$cfae44f0dfdf62c0$var$cachedSetTimeout) && setTimeout) {\n        $cfae44f0dfdf62c0$var$cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return $cfae44f0dfdf62c0$var$cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return $cfae44f0dfdf62c0$var$cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return $cfae44f0dfdf62c0$var$cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction $cfae44f0dfdf62c0$var$runClearTimeout(marker) {\n    if ($cfae44f0dfdf62c0$var$cachedClearTimeout === clearTimeout) //normal enviroments in sane situations\n    return clearTimeout(marker);\n    // if clearTimeout wasn't available but was latter defined\n    if (($cfae44f0dfdf62c0$var$cachedClearTimeout === $cfae44f0dfdf62c0$var$defaultClearTimeout || !$cfae44f0dfdf62c0$var$cachedClearTimeout) && clearTimeout) {\n        $cfae44f0dfdf62c0$var$cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return $cfae44f0dfdf62c0$var$cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return $cfae44f0dfdf62c0$var$cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return $cfae44f0dfdf62c0$var$cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar $cfae44f0dfdf62c0$var$queue = [];\nvar $cfae44f0dfdf62c0$var$draining = false;\nvar $cfae44f0dfdf62c0$var$currentQueue;\nvar $cfae44f0dfdf62c0$var$queueIndex = -1;\nfunction $cfae44f0dfdf62c0$var$cleanUpNextTick() {\n    if (!$cfae44f0dfdf62c0$var$draining || !$cfae44f0dfdf62c0$var$currentQueue) return;\n    $cfae44f0dfdf62c0$var$draining = false;\n    if ($cfae44f0dfdf62c0$var$currentQueue.length) $cfae44f0dfdf62c0$var$queue = $cfae44f0dfdf62c0$var$currentQueue.concat($cfae44f0dfdf62c0$var$queue);\n    else $cfae44f0dfdf62c0$var$queueIndex = -1;\n    if ($cfae44f0dfdf62c0$var$queue.length) $cfae44f0dfdf62c0$var$drainQueue();\n}\nfunction $cfae44f0dfdf62c0$var$drainQueue() {\n    if ($cfae44f0dfdf62c0$var$draining) return;\n    var timeout = $cfae44f0dfdf62c0$var$runTimeout($cfae44f0dfdf62c0$var$cleanUpNextTick);\n    $cfae44f0dfdf62c0$var$draining = true;\n    var len = $cfae44f0dfdf62c0$var$queue.length;\n    while(len){\n        $cfae44f0dfdf62c0$var$currentQueue = $cfae44f0dfdf62c0$var$queue;\n        $cfae44f0dfdf62c0$var$queue = [];\n        while(++$cfae44f0dfdf62c0$var$queueIndex < len)if ($cfae44f0dfdf62c0$var$currentQueue) $cfae44f0dfdf62c0$var$currentQueue[$cfae44f0dfdf62c0$var$queueIndex].run();\n        $cfae44f0dfdf62c0$var$queueIndex = -1;\n        len = $cfae44f0dfdf62c0$var$queue.length;\n    }\n    $cfae44f0dfdf62c0$var$currentQueue = null;\n    $cfae44f0dfdf62c0$var$draining = false;\n    $cfae44f0dfdf62c0$var$runClearTimeout(timeout);\n}\n$cfae44f0dfdf62c0$var$process.nextTick = function(fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];\n    $cfae44f0dfdf62c0$var$queue.push(new $cfae44f0dfdf62c0$var$Item(fun, args));\n    if ($cfae44f0dfdf62c0$var$queue.length === 1 && !$cfae44f0dfdf62c0$var$draining) $cfae44f0dfdf62c0$var$runTimeout($cfae44f0dfdf62c0$var$drainQueue);\n};\n// v8 likes predictible objects\nfunction $cfae44f0dfdf62c0$var$Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\n$cfae44f0dfdf62c0$var$Item.prototype.run = function() {\n    this.fun.apply(null, this.array);\n};\n$cfae44f0dfdf62c0$var$process.title = \"browser\";\n$cfae44f0dfdf62c0$var$process.browser = true;\n$cfae44f0dfdf62c0$var$process.env = {};\n$cfae44f0dfdf62c0$var$process.argv = [];\n$cfae44f0dfdf62c0$var$process.version = \"\"; // empty string to avoid regexp issues\n$cfae44f0dfdf62c0$var$process.versions = {};\nfunction $cfae44f0dfdf62c0$var$noop() {}\n$cfae44f0dfdf62c0$var$process.on = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.addListener = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.once = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.off = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.removeListener = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.removeAllListeners = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.emit = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.prependListener = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.prependOnceListener = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.listeners = function(name) {\n    return [];\n};\n$cfae44f0dfdf62c0$var$process.binding = function(name) {\n    throw new Error(\"process.binding is not supported\");\n};\n$cfae44f0dfdf62c0$var$process.cwd = function() {\n    return \"/\";\n};\n$cfae44f0dfdf62c0$var$process.chdir = function(dir) {\n    throw new Error(\"process.chdir is not supported\");\n};\n$cfae44f0dfdf62c0$var$process.umask = function() {\n    return 0;\n};\n\n\nvar $abc9fcc4b1165aa9$exports = {};\n$abc9fcc4b1165aa9$exports = new URL(\"sort.594a65d3.wasm\", import.meta.url).toString();\n\n\nvar $b9f4e619498c4711$var$Module = (()=>{\n    var _scriptDir = \"file:///node_modules/@zappar/three-gaussian-splat/lib/cpp-sorter/sort.js\";\n    return function(moduleArg = {}) {\n        var Module = moduleArg;\n        var readyPromiseResolve, readyPromiseReject;\n        Module[\"ready\"] = new Promise((resolve, reject)=>{\n            readyPromiseResolve = resolve;\n            readyPromiseReject = reject;\n        });\n        var moduleOverrides = Object.assign({}, Module);\n        var arguments_ = [];\n        var thisProgram = \"./this.program\";\n        var quit_ = (status, toThrow)=>{\n            throw toThrow;\n        };\n        var ENVIRONMENT_IS_WEB = typeof window == \"object\";\n        var ENVIRONMENT_IS_WORKER = typeof importScripts == \"function\";\n        var ENVIRONMENT_IS_NODE = typeof $cfae44f0dfdf62c0$exports == \"object\" && typeof $cfae44f0dfdf62c0$exports.versions == \"object\" && typeof $cfae44f0dfdf62c0$exports.versions.node == \"string\";\n        var scriptDirectory = \"\";\n        function locateFile(path) {\n            if (Module[\"locateFile\"]) return Module[\"locateFile\"](path, scriptDirectory);\n            return scriptDirectory + path;\n        }\n        var read_, readAsync, readBinary;\n        if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n            if (ENVIRONMENT_IS_WORKER) scriptDirectory = self.location.href;\n            else if (typeof document != \"undefined\" && document.currentScript) scriptDirectory = document.currentScript.src;\n            if (_scriptDir) scriptDirectory = _scriptDir;\n            if (scriptDirectory.indexOf(\"blob:\") !== 0) scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1);\n            else scriptDirectory = \"\";\n            read_ = (url)=>{\n                var xhr = new XMLHttpRequest;\n                xhr.open(\"GET\", url, false);\n                xhr.send(null);\n                return xhr.responseText;\n            };\n            if (ENVIRONMENT_IS_WORKER) readBinary = (url)=>{\n                var xhr = new XMLHttpRequest;\n                xhr.open(\"GET\", url, false);\n                xhr.responseType = \"arraybuffer\";\n                xhr.send(null);\n                return new Uint8Array(xhr.response);\n            };\n            readAsync = (url, onload, onerror)=>{\n                var xhr = new XMLHttpRequest;\n                xhr.open(\"GET\", url, true);\n                xhr.responseType = \"arraybuffer\";\n                xhr.onload = ()=>{\n                    if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n                        onload(xhr.response);\n                        return;\n                    }\n                    onerror();\n                };\n                xhr.onerror = onerror;\n                xhr.send(null);\n            };\n        }\n        var out = Module[\"print\"] || console.log.bind(console);\n        var err = Module[\"printErr\"] || console.error.bind(console);\n        Object.assign(Module, moduleOverrides);\n        moduleOverrides = null;\n        if (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n        if (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n        if (Module[\"quit\"]) quit_ = Module[\"quit\"];\n        var wasmBinary;\n        if (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\n        if (typeof WebAssembly != \"object\") abort(\"no native wasm support detected\");\n        var wasmMemory;\n        var ABORT = false;\n        var EXITSTATUS;\n        var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n        function updateMemoryViews() {\n            var b = wasmMemory.buffer;\n            Module[\"HEAP8\"] = HEAP8 = new Int8Array(b);\n            Module[\"HEAP16\"] = HEAP16 = new Int16Array(b);\n            Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(b);\n            Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(b);\n            Module[\"HEAP32\"] = HEAP32 = new Int32Array(b);\n            Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(b);\n            Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(b);\n            Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(b);\n        }\n        var __ATPRERUN__ = [];\n        var __ATINIT__ = [];\n        var __ATPOSTRUN__ = [];\n        var runtimeInitialized = false;\n        function preRun() {\n            if (Module[\"preRun\"]) {\n                if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [\n                    Module[\"preRun\"]\n                ];\n                while(Module[\"preRun\"].length)addOnPreRun(Module[\"preRun\"].shift());\n            }\n            callRuntimeCallbacks(__ATPRERUN__);\n        }\n        function initRuntime() {\n            runtimeInitialized = true;\n            callRuntimeCallbacks(__ATINIT__);\n        }\n        function postRun() {\n            if (Module[\"postRun\"]) {\n                if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [\n                    Module[\"postRun\"]\n                ];\n                while(Module[\"postRun\"].length)addOnPostRun(Module[\"postRun\"].shift());\n            }\n            callRuntimeCallbacks(__ATPOSTRUN__);\n        }\n        function addOnPreRun(cb) {\n            __ATPRERUN__.unshift(cb);\n        }\n        function addOnInit(cb) {\n            __ATINIT__.unshift(cb);\n        }\n        function addOnPostRun(cb) {\n            __ATPOSTRUN__.unshift(cb);\n        }\n        var runDependencies = 0;\n        var runDependencyWatcher = null;\n        var dependenciesFulfilled = null;\n        function addRunDependency(id) {\n            runDependencies++;\n            if (Module[\"monitorRunDependencies\"]) Module[\"monitorRunDependencies\"](runDependencies);\n        }\n        function removeRunDependency(id) {\n            runDependencies--;\n            if (Module[\"monitorRunDependencies\"]) Module[\"monitorRunDependencies\"](runDependencies);\n            if (runDependencies == 0) {\n                if (runDependencyWatcher !== null) {\n                    clearInterval(runDependencyWatcher);\n                    runDependencyWatcher = null;\n                }\n                if (dependenciesFulfilled) {\n                    var callback = dependenciesFulfilled;\n                    dependenciesFulfilled = null;\n                    callback();\n                }\n            }\n        }\n        function abort(what) {\n            if (Module[\"onAbort\"]) Module[\"onAbort\"](what);\n            what = \"Aborted(\" + what + \")\";\n            err(what);\n            ABORT = true;\n            EXITSTATUS = 1;\n            what += \". Build with -sASSERTIONS for more info.\";\n            var e = new WebAssembly.RuntimeError(what);\n            readyPromiseReject(e);\n            throw e;\n        }\n        var dataURIPrefix = \"data:application/octet-stream;base64,\";\n        var isDataURI = (filename)=>filename.startsWith(dataURIPrefix);\n        var wasmBinaryFile;\n        if (Module[\"locateFile\"]) {\n            wasmBinaryFile = \"sort.wasm\";\n            if (!isDataURI(wasmBinaryFile)) wasmBinaryFile = locateFile(wasmBinaryFile);\n        } else wasmBinaryFile = new URL($abc9fcc4b1165aa9$exports).href;\n        function getBinarySync(file) {\n            if (file == wasmBinaryFile && wasmBinary) return new Uint8Array(wasmBinary);\n            if (readBinary) return readBinary(file);\n            throw \"both async and sync fetching of the wasm failed\";\n        }\n        function getBinaryPromise(binaryFile) {\n            if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n                if (typeof fetch == \"function\") return fetch(binaryFile, {\n                    credentials: \"same-origin\"\n                }).then((response)=>{\n                    if (!response[\"ok\"]) throw \"failed to load wasm binary file at '\" + binaryFile + \"'\";\n                    return response[\"arrayBuffer\"]();\n                }).catch(()=>getBinarySync(binaryFile));\n            }\n            return Promise.resolve().then(()=>getBinarySync(binaryFile));\n        }\n        function instantiateArrayBuffer(binaryFile, imports, receiver) {\n            return getBinaryPromise(binaryFile).then((binary)=>WebAssembly.instantiate(binary, imports)).then((instance)=>instance).then(receiver, (reason)=>{\n                err(`failed to asynchronously prepare wasm: ${reason}`);\n                abort(reason);\n            });\n        }\n        function instantiateAsync(binary, binaryFile, imports, callback) {\n            if (!binary && typeof WebAssembly.instantiateStreaming == \"function\" && !isDataURI(binaryFile) && typeof fetch == \"function\") return fetch(binaryFile, {\n                credentials: \"same-origin\"\n            }).then((response)=>{\n                var result = WebAssembly.instantiateStreaming(response, imports);\n                return result.then(callback, function(reason) {\n                    err(`wasm streaming compile failed: ${reason}`);\n                    err(\"falling back to ArrayBuffer instantiation\");\n                    return instantiateArrayBuffer(binaryFile, imports, callback);\n                });\n            });\n            return instantiateArrayBuffer(binaryFile, imports, callback);\n        }\n        function createWasm() {\n            var info = {\n                \"a\": wasmImports\n            };\n            function receiveInstance(instance, module) {\n                wasmExports = instance.exports;\n                wasmMemory = wasmExports[\"o\"];\n                updateMemoryViews();\n                wasmTable = wasmExports[\"s\"];\n                addOnInit(wasmExports[\"p\"]);\n                removeRunDependency(\"wasm-instantiate\");\n                return wasmExports;\n            }\n            addRunDependency(\"wasm-instantiate\");\n            function receiveInstantiationResult(result) {\n                receiveInstance(result[\"instance\"]);\n            }\n            if (Module[\"instantiateWasm\"]) try {\n                return Module[\"instantiateWasm\"](info, receiveInstance);\n            } catch (e) {\n                err(`Module.instantiateWasm callback failed with error: ${e}`);\n                readyPromiseReject(e);\n            }\n            instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);\n            return {};\n        }\n        var callRuntimeCallbacks = (callbacks)=>{\n            while(callbacks.length > 0)callbacks.shift()(Module);\n        };\n        var noExitRuntime = Module[\"noExitRuntime\"] || true;\n        function ExceptionInfo(excPtr) {\n            this.excPtr = excPtr;\n            this.ptr = excPtr - 24;\n            this.set_type = function(type) {\n                HEAPU32[this.ptr + 4 >> 2] = type;\n            };\n            this.get_type = function() {\n                return HEAPU32[this.ptr + 4 >> 2];\n            };\n            this.set_destructor = function(destructor) {\n                HEAPU32[this.ptr + 8 >> 2] = destructor;\n            };\n            this.get_destructor = function() {\n                return HEAPU32[this.ptr + 8 >> 2];\n            };\n            this.set_caught = function(caught) {\n                caught = caught ? 1 : 0;\n                HEAP8[this.ptr + 12 >> 0] = caught;\n            };\n            this.get_caught = function() {\n                return HEAP8[this.ptr + 12 >> 0] != 0;\n            };\n            this.set_rethrown = function(rethrown) {\n                rethrown = rethrown ? 1 : 0;\n                HEAP8[this.ptr + 13 >> 0] = rethrown;\n            };\n            this.get_rethrown = function() {\n                return HEAP8[this.ptr + 13 >> 0] != 0;\n            };\n            this.init = function(type, destructor) {\n                this.set_adjusted_ptr(0);\n                this.set_type(type);\n                this.set_destructor(destructor);\n            };\n            this.set_adjusted_ptr = function(adjustedPtr) {\n                HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;\n            };\n            this.get_adjusted_ptr = function() {\n                return HEAPU32[this.ptr + 16 >> 2];\n            };\n            this.get_exception_ptr = function() {\n                var isPointer = ___cxa_is_pointer_type(this.get_type());\n                if (isPointer) return HEAPU32[this.excPtr >> 2];\n                var adjusted = this.get_adjusted_ptr();\n                if (adjusted !== 0) return adjusted;\n                return this.excPtr;\n            };\n        }\n        var exceptionLast = 0;\n        var uncaughtExceptionCount = 0;\n        var ___cxa_throw = (ptr, type, destructor)=>{\n            var info = new ExceptionInfo(ptr);\n            info.init(type, destructor);\n            exceptionLast = ptr;\n            uncaughtExceptionCount++;\n            throw exceptionLast;\n        };\n        var __embind_register_bigint = (primitiveType, name, size, minRange, maxRange)=>{};\n        var embind_init_charCodes = ()=>{\n            var codes = new Array(256);\n            for(var i = 0; i < 256; ++i)codes[i] = String.fromCharCode(i);\n            embind_charCodes = codes;\n        };\n        var embind_charCodes;\n        var readLatin1String = (ptr)=>{\n            var ret = \"\";\n            var c = ptr;\n            while(HEAPU8[c])ret += embind_charCodes[HEAPU8[c++]];\n            return ret;\n        };\n        var awaitingDependencies = {};\n        var registeredTypes = {};\n        var typeDependencies = {};\n        var BindingError;\n        var throwBindingError = (message)=>{\n            throw new BindingError(message);\n        };\n        var InternalError;\n        var throwInternalError = (message)=>{\n            throw new InternalError(message);\n        };\n        var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters)=>{\n            myTypes.forEach(function(type) {\n                typeDependencies[type] = dependentTypes;\n            });\n            function onComplete(typeConverters) {\n                var myTypeConverters = getTypeConverters(typeConverters);\n                if (myTypeConverters.length !== myTypes.length) throwInternalError(\"Mismatched type converter count\");\n                for(var i = 0; i < myTypes.length; ++i)registerType(myTypes[i], myTypeConverters[i]);\n            }\n            var typeConverters = new Array(dependentTypes.length);\n            var unregisteredTypes = [];\n            var registered = 0;\n            dependentTypes.forEach((dt, i)=>{\n                if (registeredTypes.hasOwnProperty(dt)) typeConverters[i] = registeredTypes[dt];\n                else {\n                    unregisteredTypes.push(dt);\n                    if (!awaitingDependencies.hasOwnProperty(dt)) awaitingDependencies[dt] = [];\n                    awaitingDependencies[dt].push(()=>{\n                        typeConverters[i] = registeredTypes[dt];\n                        ++registered;\n                        if (registered === unregisteredTypes.length) onComplete(typeConverters);\n                    });\n                }\n            });\n            if (0 === unregisteredTypes.length) onComplete(typeConverters);\n        };\n        function sharedRegisterType(rawType, registeredInstance, options = {}) {\n            var name = registeredInstance.name;\n            if (!rawType) throwBindingError(`type \"${name}\" must have a positive integer typeid pointer`);\n            if (registeredTypes.hasOwnProperty(rawType)) {\n                if (options.ignoreDuplicateRegistrations) return;\n                else throwBindingError(`Cannot register type '${name}' twice`);\n            }\n            registeredTypes[rawType] = registeredInstance;\n            delete typeDependencies[rawType];\n            if (awaitingDependencies.hasOwnProperty(rawType)) {\n                var callbacks = awaitingDependencies[rawType];\n                delete awaitingDependencies[rawType];\n                callbacks.forEach((cb)=>cb());\n            }\n        }\n        function registerType(rawType, registeredInstance, options = {}) {\n            if (!(\"argPackAdvance\" in registeredInstance)) throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n            return sharedRegisterType(rawType, registeredInstance, options);\n        }\n        var GenericWireTypeSize = 8;\n        var __embind_register_bool = (rawType, name, trueValue, falseValue)=>{\n            name = readLatin1String(name);\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": function(wt) {\n                    return !!wt;\n                },\n                \"toWireType\": function(destructors, o) {\n                    return o ? trueValue : falseValue;\n                },\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": function(pointer) {\n                    return this[\"fromWireType\"](HEAPU8[pointer]);\n                },\n                destructorFunction: null\n            });\n        };\n        function handleAllocatorInit() {\n            Object.assign(HandleAllocator.prototype, {\n                get (id) {\n                    return this.allocated[id];\n                },\n                has (id) {\n                    return this.allocated[id] !== undefined;\n                },\n                allocate (handle) {\n                    var id = this.freelist.pop() || this.allocated.length;\n                    this.allocated[id] = handle;\n                    return id;\n                },\n                free (id) {\n                    this.allocated[id] = undefined;\n                    this.freelist.push(id);\n                }\n            });\n        }\n        function HandleAllocator() {\n            this.allocated = [\n                undefined\n            ];\n            this.freelist = [];\n        }\n        var emval_handles = new HandleAllocator;\n        var __emval_decref = (handle)=>{\n            if (handle >= emval_handles.reserved && 0 === --emval_handles.get(handle).refcount) emval_handles.free(handle);\n        };\n        var count_emval_handles = ()=>{\n            var count = 0;\n            for(var i = emval_handles.reserved; i < emval_handles.allocated.length; ++i)if (emval_handles.allocated[i] !== undefined) ++count;\n            return count;\n        };\n        var init_emval = ()=>{\n            emval_handles.allocated.push({\n                value: undefined\n            }, {\n                value: null\n            }, {\n                value: true\n            }, {\n                value: false\n            });\n            emval_handles.reserved = emval_handles.allocated.length;\n            Module[\"count_emval_handles\"] = count_emval_handles;\n        };\n        var Emval = {\n            toValue: (handle)=>{\n                if (!handle) throwBindingError(\"Cannot use deleted val. handle = \" + handle);\n                return emval_handles.get(handle).value;\n            },\n            toHandle: (value)=>{\n                switch(value){\n                    case undefined:\n                        return 1;\n                    case null:\n                        return 2;\n                    case true:\n                        return 3;\n                    case false:\n                        return 4;\n                    default:\n                        return emval_handles.allocate({\n                            refcount: 1,\n                            value: value\n                        });\n                }\n            }\n        };\n        function simpleReadValueFromPointer(pointer) {\n            return this[\"fromWireType\"](HEAP32[pointer >> 2]);\n        }\n        var __embind_register_emval = (rawType, name)=>{\n            name = readLatin1String(name);\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": (handle)=>{\n                    var rv = Emval.toValue(handle);\n                    __emval_decref(handle);\n                    return rv;\n                },\n                \"toWireType\": (destructors, value)=>Emval.toHandle(value),\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": simpleReadValueFromPointer,\n                destructorFunction: null\n            });\n        };\n        var floatReadValueFromPointer = (name, width)=>{\n            switch(width){\n                case 4:\n                    return function(pointer) {\n                        return this[\"fromWireType\"](HEAPF32[pointer >> 2]);\n                    };\n                case 8:\n                    return function(pointer) {\n                        return this[\"fromWireType\"](HEAPF64[pointer >> 3]);\n                    };\n                default:\n                    throw new TypeError(`invalid float width (${width}): ${name}`);\n            }\n        };\n        var __embind_register_float = (rawType, name, size)=>{\n            name = readLatin1String(name);\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": (value)=>value,\n                \"toWireType\": (destructors, value)=>value,\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": floatReadValueFromPointer(name, size),\n                destructorFunction: null\n            });\n        };\n        var createNamedFunction = (name, body)=>Object.defineProperty(body, \"name\", {\n                value: name\n            });\n        var runDestructors = (destructors)=>{\n            while(destructors.length){\n                var ptr = destructors.pop();\n                var del = destructors.pop();\n                del(ptr);\n            }\n        };\n        function newFunc(constructor, argumentList) {\n            if (!(constructor instanceof Function)) throw new TypeError(`new_ called with constructor type ${typeof constructor} which is not a function`);\n            var dummy = createNamedFunction(constructor.name || \"unknownFunctionName\", function() {});\n            dummy.prototype = constructor.prototype;\n            var obj = new dummy;\n            var r = constructor.apply(obj, argumentList);\n            return r instanceof Object ? r : obj;\n        }\n        function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, isAsync) {\n            var argCount = argTypes.length;\n            if (argCount < 2) throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n            var isClassMethodFunc = argTypes[1] !== null && classType !== null;\n            var needsDestructorStack = false;\n            for(var i = 1; i < argTypes.length; ++i)if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {\n                needsDestructorStack = true;\n                break;\n            }\n            var returns = argTypes[0].name !== \"void\";\n            var argsList = \"\";\n            var argsListWired = \"\";\n            for(var i = 0; i < argCount - 2; ++i){\n                argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\n                argsListWired += (i !== 0 ? \", \" : \"\") + \"arg\" + i + \"Wired\";\n            }\n            var invokerFnBody = `\\n        return function (${argsList}) {\\n        if (arguments.length !== ${argCount - 2}) {\\n          throwBindingError('function ${humanName} called with ' + arguments.length + ' arguments, expected ${argCount - 2}');\\n        }`;\n            if (needsDestructorStack) invokerFnBody += \"var destructors = [];\\n\";\n            var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n            var args1 = [\n                \"throwBindingError\",\n                \"invoker\",\n                \"fn\",\n                \"runDestructors\",\n                \"retType\",\n                \"classParam\"\n            ];\n            var args2 = [\n                throwBindingError,\n                cppInvokerFunc,\n                cppTargetFunc,\n                runDestructors,\n                argTypes[0],\n                argTypes[1]\n            ];\n            if (isClassMethodFunc) invokerFnBody += \"var thisWired = classParam.toWireType(\" + dtorStack + \", this);\\n\";\n            for(var i = 0; i < argCount - 2; ++i){\n                invokerFnBody += \"var arg\" + i + \"Wired = argType\" + i + \".toWireType(\" + dtorStack + \", arg\" + i + \"); // \" + argTypes[i + 2].name + \"\\n\";\n                args1.push(\"argType\" + i);\n                args2.push(argTypes[i + 2]);\n            }\n            if (isClassMethodFunc) argsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\n            invokerFnBody += (returns || isAsync ? \"var rv = \" : \"\") + \"invoker(fn\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired + \");\\n\";\n            if (needsDestructorStack) invokerFnBody += \"runDestructors(destructors);\\n\";\n            else for(var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i){\n                var paramName = i === 1 ? \"thisWired\" : \"arg\" + (i - 2) + \"Wired\";\n                if (argTypes[i].destructorFunction !== null) {\n                    invokerFnBody += paramName + \"_dtor(\" + paramName + \"); // \" + argTypes[i].name + \"\\n\";\n                    args1.push(paramName + \"_dtor\");\n                    args2.push(argTypes[i].destructorFunction);\n                }\n            }\n            if (returns) invokerFnBody += \"var ret = retType.fromWireType(rv);\\nreturn ret;\\n\";\n            invokerFnBody += \"}\\n\";\n            args1.push(invokerFnBody);\n            var invokerFn = newFunc(Function, args1).apply(null, args2);\n            return createNamedFunction(humanName, invokerFn);\n        }\n        var ensureOverloadTable = (proto, methodName, humanName)=>{\n            if (undefined === proto[methodName].overloadTable) {\n                var prevFunc = proto[methodName];\n                proto[methodName] = function() {\n                    if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${arguments.length}) - expects one of (${proto[methodName].overloadTable})!`);\n                    return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\n                };\n                proto[methodName].overloadTable = [];\n                proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n            }\n        };\n        var exposePublicSymbol = (name, value, numArguments)=>{\n            if (Module.hasOwnProperty(name)) {\n                if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) throwBindingError(`Cannot register public name '${name}' twice`);\n                ensureOverloadTable(Module, name, name);\n                if (Module.hasOwnProperty(numArguments)) throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);\n                Module[name].overloadTable[numArguments] = value;\n            } else {\n                Module[name] = value;\n                if (undefined !== numArguments) Module[name].numArguments = numArguments;\n            }\n        };\n        var heap32VectorToArray = (count, firstElement)=>{\n            var array = [];\n            for(var i = 0; i < count; i++)array.push(HEAPU32[firstElement + i * 4 >> 2]);\n            return array;\n        };\n        var replacePublicSymbol = (name, value, numArguments)=>{\n            if (!Module.hasOwnProperty(name)) throwInternalError(\"Replacing nonexistant public symbol\");\n            if (undefined !== Module[name].overloadTable && undefined !== numArguments) Module[name].overloadTable[numArguments] = value;\n            else {\n                Module[name] = value;\n                Module[name].argCount = numArguments;\n            }\n        };\n        var dynCallLegacy = (sig, ptr, args)=>{\n            var f = Module[\"dynCall_\" + sig];\n            return args && args.length ? f.apply(null, [\n                ptr\n            ].concat(args)) : f.call(null, ptr);\n        };\n        var wasmTableMirror = [];\n        var wasmTable;\n        var getWasmTableEntry = (funcPtr)=>{\n            var func = wasmTableMirror[funcPtr];\n            if (!func) {\n                if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\n                wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n            }\n            return func;\n        };\n        var dynCall = (sig, ptr, args)=>{\n            if (sig.includes(\"j\")) return dynCallLegacy(sig, ptr, args);\n            var rtn = getWasmTableEntry(ptr).apply(null, args);\n            return rtn;\n        };\n        var getDynCaller = (sig, ptr)=>{\n            var argCache = [];\n            return function() {\n                argCache.length = 0;\n                Object.assign(argCache, arguments);\n                return dynCall(sig, ptr, argCache);\n            };\n        };\n        var embind__requireFunction = (signature, rawFunction)=>{\n            signature = readLatin1String(signature);\n            function makeDynCaller() {\n                if (signature.includes(\"j\")) return getDynCaller(signature, rawFunction);\n                return getWasmTableEntry(rawFunction);\n            }\n            var fp = makeDynCaller();\n            if (typeof fp != \"function\") throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);\n            return fp;\n        };\n        var extendError = (baseErrorType, errorName)=>{\n            var errorClass = createNamedFunction(errorName, function(message) {\n                this.name = errorName;\n                this.message = message;\n                var stack = new Error(message).stack;\n                if (stack !== undefined) this.stack = this.toString() + \"\\n\" + stack.replace(/^Error(:[^\\n]*)?\\n/, \"\");\n            });\n            errorClass.prototype = Object.create(baseErrorType.prototype);\n            errorClass.prototype.constructor = errorClass;\n            errorClass.prototype.toString = function() {\n                if (this.message === undefined) return this.name;\n                else return `${this.name}: ${this.message}`;\n            };\n            return errorClass;\n        };\n        var UnboundTypeError;\n        var getTypeName = (type)=>{\n            var ptr = ___getTypeName(type);\n            var rv = readLatin1String(ptr);\n            _free(ptr);\n            return rv;\n        };\n        var throwUnboundTypeError = (message, types)=>{\n            var unboundTypes = [];\n            var seen = {};\n            function visit(type) {\n                if (seen[type]) return;\n                if (registeredTypes[type]) return;\n                if (typeDependencies[type]) {\n                    typeDependencies[type].forEach(visit);\n                    return;\n                }\n                unboundTypes.push(type);\n                seen[type] = true;\n            }\n            types.forEach(visit);\n            throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([\n                \", \"\n            ]));\n        };\n        var getFunctionName = (signature)=>{\n            signature = signature.trim();\n            const argsIndex = signature.indexOf(\"(\");\n            if (argsIndex !== -1) return signature.substr(0, argsIndex);\n            else return signature;\n        };\n        var __embind_register_function = (name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync)=>{\n            var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n            name = readLatin1String(name);\n            name = getFunctionName(name);\n            rawInvoker = embind__requireFunction(signature, rawInvoker);\n            exposePublicSymbol(name, function() {\n                throwUnboundTypeError(`Cannot call ${name} due to unbound types`, argTypes);\n            }, argCount - 1);\n            whenDependentTypesAreResolved([], argTypes, function(argTypes) {\n                var invokerArgsArray = [\n                    argTypes[0],\n                    null\n                ].concat(argTypes.slice(1));\n                replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn, isAsync), argCount - 1);\n                return [];\n            });\n        };\n        var integerReadValueFromPointer = (name, width, signed)=>{\n            switch(width){\n                case 1:\n                    return signed ? (pointer)=>HEAP8[pointer >> 0] : (pointer)=>HEAPU8[pointer >> 0];\n                case 2:\n                    return signed ? (pointer)=>HEAP16[pointer >> 1] : (pointer)=>HEAPU16[pointer >> 1];\n                case 4:\n                    return signed ? (pointer)=>HEAP32[pointer >> 2] : (pointer)=>HEAPU32[pointer >> 2];\n                default:\n                    throw new TypeError(`invalid integer width (${width}): ${name}`);\n            }\n        };\n        var __embind_register_integer = (primitiveType, name, size, minRange, maxRange)=>{\n            name = readLatin1String(name);\n            if (maxRange === -1) maxRange = 4294967295;\n            var fromWireType = (value)=>value;\n            if (minRange === 0) {\n                var bitshift = 32 - 8 * size;\n                fromWireType = (value)=>value << bitshift >>> bitshift;\n            }\n            var isUnsignedType = name.includes(\"unsigned\");\n            var checkAssertions = (value, toTypeName)=>{};\n            var toWireType;\n            if (isUnsignedType) toWireType = function(destructors, value) {\n                checkAssertions(value, this.name);\n                return value >>> 0;\n            };\n            else toWireType = function(destructors, value) {\n                checkAssertions(value, this.name);\n                return value;\n            };\n            registerType(primitiveType, {\n                name: name,\n                \"fromWireType\": fromWireType,\n                \"toWireType\": toWireType,\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": integerReadValueFromPointer(name, size, minRange !== 0),\n                destructorFunction: null\n            });\n        };\n        var __embind_register_memory_view = (rawType, dataTypeIndex, name)=>{\n            var typeMapping = [\n                Int8Array,\n                Uint8Array,\n                Int16Array,\n                Uint16Array,\n                Int32Array,\n                Uint32Array,\n                Float32Array,\n                Float64Array\n            ];\n            var TA = typeMapping[dataTypeIndex];\n            function decodeMemoryView(handle) {\n                var size = HEAPU32[handle >> 2];\n                var data = HEAPU32[handle + 4 >> 2];\n                return new TA(HEAP8.buffer, data, size);\n            }\n            name = readLatin1String(name);\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": decodeMemoryView,\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": decodeMemoryView\n            }, {\n                ignoreDuplicateRegistrations: true\n            });\n        };\n        function readPointer(pointer) {\n            return this[\"fromWireType\"](HEAPU32[pointer >> 2]);\n        }\n        var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite)=>{\n            if (!(maxBytesToWrite > 0)) return 0;\n            var startIdx = outIdx;\n            var endIdx = outIdx + maxBytesToWrite - 1;\n            for(var i = 0; i < str.length; ++i){\n                var u = str.charCodeAt(i);\n                if (u >= 55296 && u <= 57343) {\n                    var u1 = str.charCodeAt(++i);\n                    u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n                }\n                if (u <= 127) {\n                    if (outIdx >= endIdx) break;\n                    heap[outIdx++] = u;\n                } else if (u <= 2047) {\n                    if (outIdx + 1 >= endIdx) break;\n                    heap[outIdx++] = 192 | u >> 6;\n                    heap[outIdx++] = 128 | u & 63;\n                } else if (u <= 65535) {\n                    if (outIdx + 2 >= endIdx) break;\n                    heap[outIdx++] = 224 | u >> 12;\n                    heap[outIdx++] = 128 | u >> 6 & 63;\n                    heap[outIdx++] = 128 | u & 63;\n                } else {\n                    if (outIdx + 3 >= endIdx) break;\n                    heap[outIdx++] = 240 | u >> 18;\n                    heap[outIdx++] = 128 | u >> 12 & 63;\n                    heap[outIdx++] = 128 | u >> 6 & 63;\n                    heap[outIdx++] = 128 | u & 63;\n                }\n            }\n            heap[outIdx] = 0;\n            return outIdx - startIdx;\n        };\n        var stringToUTF8 = (str, outPtr, maxBytesToWrite)=>stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n        var lengthBytesUTF8 = (str)=>{\n            var len = 0;\n            for(var i = 0; i < str.length; ++i){\n                var c = str.charCodeAt(i);\n                if (c <= 127) len++;\n                else if (c <= 2047) len += 2;\n                else if (c >= 55296 && c <= 57343) {\n                    len += 4;\n                    ++i;\n                } else len += 3;\n            }\n            return len;\n        };\n        var UTF8Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n        var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead)=>{\n            var endIdx = idx + maxBytesToRead;\n            var endPtr = idx;\n            while(heapOrArray[endPtr] && !(endPtr >= endIdx))++endPtr;\n            if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n            var str = \"\";\n            while(idx < endPtr){\n                var u0 = heapOrArray[idx++];\n                if (!(u0 & 128)) {\n                    str += String.fromCharCode(u0);\n                    continue;\n                }\n                var u1 = heapOrArray[idx++] & 63;\n                if ((u0 & 224) == 192) {\n                    str += String.fromCharCode((u0 & 31) << 6 | u1);\n                    continue;\n                }\n                var u2 = heapOrArray[idx++] & 63;\n                if ((u0 & 240) == 224) u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n                else u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;\n                if (u0 < 65536) str += String.fromCharCode(u0);\n                else {\n                    var ch = u0 - 65536;\n                    str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n                }\n            }\n            return str;\n        };\n        var UTF8ToString = (ptr, maxBytesToRead)=>ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n        var __embind_register_std_string = (rawType, name)=>{\n            name = readLatin1String(name);\n            var stdStringIsUTF8 = name === \"std::string\";\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\" (value) {\n                    var length = HEAPU32[value >> 2];\n                    var payload = value + 4;\n                    var str;\n                    if (stdStringIsUTF8) {\n                        var decodeStartPtr = payload;\n                        for(var i = 0; i <= length; ++i){\n                            var currentBytePtr = payload + i;\n                            if (i == length || HEAPU8[currentBytePtr] == 0) {\n                                var maxRead = currentBytePtr - decodeStartPtr;\n                                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n                                if (str === undefined) str = stringSegment;\n                                else {\n                                    str += String.fromCharCode(0);\n                                    str += stringSegment;\n                                }\n                                decodeStartPtr = currentBytePtr + 1;\n                            }\n                        }\n                    } else {\n                        var a = new Array(length);\n                        for(var i = 0; i < length; ++i)a[i] = String.fromCharCode(HEAPU8[payload + i]);\n                        str = a.join(\"\");\n                    }\n                    _free(value);\n                    return str;\n                },\n                \"toWireType\" (destructors, value) {\n                    if (value instanceof ArrayBuffer) value = new Uint8Array(value);\n                    var length;\n                    var valueIsOfTypeString = typeof value == \"string\";\n                    if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) throwBindingError(\"Cannot pass non-string to std::string\");\n                    if (stdStringIsUTF8 && valueIsOfTypeString) length = lengthBytesUTF8(value);\n                    else length = value.length;\n                    var base = _malloc(4 + length + 1);\n                    var ptr = base + 4;\n                    HEAPU32[base >> 2] = length;\n                    if (stdStringIsUTF8 && valueIsOfTypeString) stringToUTF8(value, ptr, length + 1);\n                    else {\n                        if (valueIsOfTypeString) for(var i = 0; i < length; ++i){\n                            var charCode = value.charCodeAt(i);\n                            if (charCode > 255) {\n                                _free(ptr);\n                                throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\");\n                            }\n                            HEAPU8[ptr + i] = charCode;\n                        }\n                        else for(var i = 0; i < length; ++i)HEAPU8[ptr + i] = value[i];\n                    }\n                    if (destructors !== null) destructors.push(_free, base);\n                    return base;\n                },\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": readPointer,\n                destructorFunction (ptr) {\n                    _free(ptr);\n                }\n            });\n        };\n        var UTF16Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\n        var UTF16ToString = (ptr, maxBytesToRead)=>{\n            var endPtr = ptr;\n            var idx = endPtr >> 1;\n            var maxIdx = idx + maxBytesToRead / 2;\n            while(!(idx >= maxIdx) && HEAPU16[idx])++idx;\n            endPtr = idx << 1;\n            if (endPtr - ptr > 32 && UTF16Decoder) return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n            var str = \"\";\n            for(var i = 0; !(i >= maxBytesToRead / 2); ++i){\n                var codeUnit = HEAP16[ptr + i * 2 >> 1];\n                if (codeUnit == 0) break;\n                str += String.fromCharCode(codeUnit);\n            }\n            return str;\n        };\n        var stringToUTF16 = (str, outPtr, maxBytesToWrite)=>{\n            if (maxBytesToWrite === undefined) maxBytesToWrite = 2147483647;\n            if (maxBytesToWrite < 2) return 0;\n            maxBytesToWrite -= 2;\n            var startPtr = outPtr;\n            var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n            for(var i = 0; i < numCharsToWrite; ++i){\n                var codeUnit = str.charCodeAt(i);\n                HEAP16[outPtr >> 1] = codeUnit;\n                outPtr += 2;\n            }\n            HEAP16[outPtr >> 1] = 0;\n            return outPtr - startPtr;\n        };\n        var lengthBytesUTF16 = (str)=>str.length * 2;\n        var UTF32ToString = (ptr, maxBytesToRead)=>{\n            var i = 0;\n            var str = \"\";\n            while(!(i >= maxBytesToRead / 4)){\n                var utf32 = HEAP32[ptr + i * 4 >> 2];\n                if (utf32 == 0) break;\n                ++i;\n                if (utf32 >= 65536) {\n                    var ch = utf32 - 65536;\n                    str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n                } else str += String.fromCharCode(utf32);\n            }\n            return str;\n        };\n        var stringToUTF32 = (str, outPtr, maxBytesToWrite)=>{\n            if (maxBytesToWrite === undefined) maxBytesToWrite = 2147483647;\n            if (maxBytesToWrite < 4) return 0;\n            var startPtr = outPtr;\n            var endPtr = startPtr + maxBytesToWrite - 4;\n            for(var i = 0; i < str.length; ++i){\n                var codeUnit = str.charCodeAt(i);\n                if (codeUnit >= 55296 && codeUnit <= 57343) {\n                    var trailSurrogate = str.charCodeAt(++i);\n                    codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;\n                }\n                HEAP32[outPtr >> 2] = codeUnit;\n                outPtr += 4;\n                if (outPtr + 4 > endPtr) break;\n            }\n            HEAP32[outPtr >> 2] = 0;\n            return outPtr - startPtr;\n        };\n        var lengthBytesUTF32 = (str)=>{\n            var len = 0;\n            for(var i = 0; i < str.length; ++i){\n                var codeUnit = str.charCodeAt(i);\n                if (codeUnit >= 55296 && codeUnit <= 57343) ++i;\n                len += 4;\n            }\n            return len;\n        };\n        var __embind_register_std_wstring = (rawType, charSize, name)=>{\n            name = readLatin1String(name);\n            var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\n            if (charSize === 2) {\n                decodeString = UTF16ToString;\n                encodeString = stringToUTF16;\n                lengthBytesUTF = lengthBytesUTF16;\n                getHeap = ()=>HEAPU16;\n                shift = 1;\n            } else if (charSize === 4) {\n                decodeString = UTF32ToString;\n                encodeString = stringToUTF32;\n                lengthBytesUTF = lengthBytesUTF32;\n                getHeap = ()=>HEAPU32;\n                shift = 2;\n            }\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": (value)=>{\n                    var length = HEAPU32[value >> 2];\n                    var HEAP = getHeap();\n                    var str;\n                    var decodeStartPtr = value + 4;\n                    for(var i = 0; i <= length; ++i){\n                        var currentBytePtr = value + 4 + i * charSize;\n                        if (i == length || HEAP[currentBytePtr >> shift] == 0) {\n                            var maxReadBytes = currentBytePtr - decodeStartPtr;\n                            var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n                            if (str === undefined) str = stringSegment;\n                            else {\n                                str += String.fromCharCode(0);\n                                str += stringSegment;\n                            }\n                            decodeStartPtr = currentBytePtr + charSize;\n                        }\n                    }\n                    _free(value);\n                    return str;\n                },\n                \"toWireType\": (destructors, value)=>{\n                    if (!(typeof value == \"string\")) throwBindingError(`Cannot pass non-string to C++ string type ${name}`);\n                    var length = lengthBytesUTF(value);\n                    var ptr = _malloc(4 + length + charSize);\n                    HEAPU32[ptr >> 2] = length >> shift;\n                    encodeString(value, ptr + 4, length + charSize);\n                    if (destructors !== null) destructors.push(_free, ptr);\n                    return ptr;\n                },\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": simpleReadValueFromPointer,\n                destructorFunction (ptr) {\n                    _free(ptr);\n                }\n            });\n        };\n        var __embind_register_void = (rawType, name)=>{\n            name = readLatin1String(name);\n            registerType(rawType, {\n                isVoid: true,\n                name: name,\n                \"argPackAdvance\": 0,\n                \"fromWireType\": ()=>undefined,\n                \"toWireType\": (destructors, o)=>undefined\n            });\n        };\n        var _abort = ()=>{\n            abort(\"\");\n        };\n        var _emscripten_memcpy_js = (dest, src, num)=>HEAPU8.copyWithin(dest, src, src + num);\n        var getHeapMax = ()=>2147483648;\n        var growMemory = (size)=>{\n            var b = wasmMemory.buffer;\n            var pages = (size - b.byteLength + 65535) / 65536;\n            try {\n                wasmMemory.grow(pages);\n                updateMemoryViews();\n                return 1;\n            } catch (e) {}\n        };\n        var _emscripten_resize_heap = (requestedSize)=>{\n            var oldSize = HEAPU8.length;\n            requestedSize >>>= 0;\n            var maxHeapSize = getHeapMax();\n            if (requestedSize > maxHeapSize) return false;\n            var alignUp = (x, multiple)=>x + (multiple - x % multiple) % multiple;\n            for(var cutDown = 1; cutDown <= 4; cutDown *= 2){\n                var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\n                overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n                var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n                var replacement = growMemory(newSize);\n                if (replacement) return true;\n            }\n            return false;\n        };\n        embind_init_charCodes();\n        BindingError = Module[\"BindingError\"] = class BindingError extends Error {\n            constructor(message){\n                super(message);\n                this.name = \"BindingError\";\n            }\n        };\n        InternalError = Module[\"InternalError\"] = class InternalError extends Error {\n            constructor(message){\n                super(message);\n                this.name = \"InternalError\";\n            }\n        };\n        handleAllocatorInit();\n        init_emval();\n        UnboundTypeError = Module[\"UnboundTypeError\"] = extendError(Error, \"UnboundTypeError\");\n        var wasmImports = {\n            n: ___cxa_throw,\n            k: __embind_register_bigint,\n            i: __embind_register_bool,\n            h: __embind_register_emval,\n            d: __embind_register_float,\n            g: __embind_register_function,\n            b: __embind_register_integer,\n            a: __embind_register_memory_view,\n            e: __embind_register_std_string,\n            c: __embind_register_std_wstring,\n            j: __embind_register_void,\n            f: _abort,\n            m: _emscripten_memcpy_js,\n            l: _emscripten_resize_heap\n        };\n        var wasmExports = createWasm();\n        var ___wasm_call_ctors = ()=>(___wasm_call_ctors = wasmExports[\"p\"])();\n        var ___getTypeName = (a0)=>(___getTypeName = wasmExports[\"q\"])(a0);\n        var ___errno_location = ()=>(___errno_location = wasmExports[\"__errno_location\"])();\n        var _malloc = Module[\"_malloc\"] = (a0)=>(_malloc = Module[\"_malloc\"] = wasmExports[\"r\"])(a0);\n        var _free = Module[\"_free\"] = (a0)=>(_free = Module[\"_free\"] = wasmExports[\"t\"])(a0);\n        var ___cxa_increment_exception_refcount = (a0)=>(___cxa_increment_exception_refcount = wasmExports[\"__cxa_increment_exception_refcount\"])(a0);\n        var ___cxa_is_pointer_type = (a0)=>(___cxa_is_pointer_type = wasmExports[\"u\"])(a0);\n        var calledRun;\n        dependenciesFulfilled = function runCaller() {\n            if (!calledRun) run();\n            if (!calledRun) dependenciesFulfilled = runCaller;\n        };\n        function run() {\n            if (runDependencies > 0) return;\n            preRun();\n            if (runDependencies > 0) return;\n            function doRun() {\n                if (calledRun) return;\n                calledRun = true;\n                Module[\"calledRun\"] = true;\n                if (ABORT) return;\n                initRuntime();\n                readyPromiseResolve(Module);\n                if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n                postRun();\n            }\n            if (Module[\"setStatus\"]) {\n                Module[\"setStatus\"](\"Running...\");\n                setTimeout(function() {\n                    setTimeout(function() {\n                        Module[\"setStatus\"](\"\");\n                    }, 1);\n                    doRun();\n                }, 1);\n            } else doRun();\n        }\n        if (Module[\"preInit\"]) {\n            if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [\n                Module[\"preInit\"]\n            ];\n            while(Module[\"preInit\"].length > 0)Module[\"preInit\"].pop()();\n        }\n        run();\n        return moduleArg.ready;\n    };\n})();\nvar $b9f4e619498c4711$export$2e2bcd8739ae039 = $b9f4e619498c4711$var$Module;\n\n\nclass $b6ad592ba86e0ced$export$6b0910223fe46ee7 {\n    constructor(bufferSize, initialPoolSize = 0){\n        this.bufferSize = bufferSize;\n        this.pool = [];\n        this.initPool(initialPoolSize);\n    }\n    initPool(initialPoolSize) {\n        for(let i = 0; i < initialPoolSize; i++)this.pool.push(new ArrayBuffer(this.bufferSize));\n    }\n    getBuffer() {\n        if (this.pool.length > 0) return this.pool.pop();\n        else return new ArrayBuffer(this.bufferSize);\n    }\n    returnBuffer(buffer) {\n        if (buffer.byteLength === this.bufferSize) this.pool.push(buffer);\n    }\n}\n\n\nclass $b2637d91d9747a63$export$2c307b8f11fd7777 {\n    constructor(vertexCount, globalBuffer){\n        this.vertexCount = vertexCount;\n        this.globalBuffer = globalBuffer;\n        const combinedLength = this.calculateCombinedLength();\n        // we're double buffering, so 2 is the magic number here\n        this.bufferPool = new (0, $b6ad592ba86e0ced$export$6b0910223fe46ee7)(combinedLength, 2);\n    }\n    async load() {\n        const sharedABSupported = typeof SharedArrayBuffer !== \"undefined\";\n        this.module = await (sharedABSupported ? (0, $b9f4e619498c4711$export$2e2bcd8739ae039)() : (0, $b9f4e619498c4711$export$2e2bcd8739ae039)());\n        this.viewProjPtr = this.module._malloc(16 * Float32Array.BYTES_PER_ELEMENT);\n        this.globalBufferPtr = this.module._malloc(this.vertexCount * 32);\n        this.combinedPtr = this.module._malloc(this.calculateCombinedLength());\n        this.module.HEAPU8.set(this.globalBuffer, this.globalBufferPtr);\n    }\n    runSort(viewProj) {\n        this.module.HEAPF32.set(viewProj, this.viewProjPtr / Float32Array.BYTES_PER_ELEMENT);\n        this.module.runSort(this.viewProjPtr, this.globalBufferPtr, this.vertexCount, this.combinedPtr);\n        const byteStart = this.combinedPtr;\n        const byteLength = this.calculateCombinedLength();\n        const bufferToTransfer = this.bufferPool.getBuffer();\n        new Uint8Array(bufferToTransfer).set(new Uint8Array(this.module.HEAPU8.buffer, byteStart, byteLength));\n        return (0, $dLq9J.transfer)(bufferToTransfer, [\n            bufferToTransfer\n        ]);\n    }\n    returnBuffer(buffer) {\n        this.bufferPool.returnBuffer(buffer);\n    }\n    calculateCombinedLength() {\n        return 16 * this.vertexCount + 12 * this.vertexCount + 12 * this.vertexCount + 16 * this.vertexCount * Float32Array.BYTES_PER_ELEMENT;\n    }\n    dispose() {\n        if (this.module) {\n            this.module._free(this.viewProjPtr);\n            this.module._free(this.globalBufferPtr);\n            this.module._free(this.combinedPtr);\n        }\n    }\n}\n(0, $dLq9J.expose)($b2637d91d9747a63$export$2c307b8f11fd7777);\n\n\n//# sourceMappingURL=worker.487a2036.js.map\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    return createProxy(ep, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        ep.addEventListener(\"message\", function l(ev) {\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\n                return;\n            }\n            ep.removeEventListener(\"message\", l);\n            resolve(ev.data);\n        });\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  Endpoint,\n  EventSource,\n  Message,\n  MessageType,\n  PostMessageWithOrigin,\n  WireValue,\n  WireValueType,\n} from \"./protocol\";\nexport type { Endpoint };\n\nexport const proxyMarker = Symbol(\"Comlink.proxy\");\nexport const createEndpoint = Symbol(\"Comlink.endpoint\");\nexport const releaseProxy = Symbol(\"Comlink.releaseProxy\");\nexport const finalizer = Symbol(\"Comlink.finalizer\");\n\nconst throwMarker = Symbol(\"Comlink.thrown\");\n\n/**\n * Interface of values that were marked to be proxied with `comlink.proxy()`.\n * Can also be implemented by classes.\n */\nexport interface ProxyMarked {\n  [proxyMarker]: true;\n}\n\n/**\n * Takes a type and wraps it in a Promise, if it not already is one.\n * This is to avoid `Promise<Promise<T>>`.\n *\n * This is the inverse of `Unpromisify<T>`.\n */\ntype Promisify<T> = T extends Promise<unknown> ? T : Promise<T>;\n/**\n * Takes a type that may be Promise and unwraps the Promise type.\n * If `P` is not a Promise, it returns `P`.\n *\n * This is the inverse of `Promisify<T>`.\n */\ntype Unpromisify<P> = P extends Promise<infer T> ? T : P;\n\n/**\n * Takes the raw type of a remote property and returns the type that is visible to the local thread on the proxy.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions.\n * See https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype RemoteProperty<T> =\n  // If the value is a method, comlink will proxy it automatically.\n  // Objects are only proxied if they are marked to be proxied.\n  // Otherwise, the property is converted to a Promise that resolves the cloned value.\n  T extends Function | ProxyMarked ? Remote<T> : Promisify<T>;\n\n/**\n * Takes the raw type of a property as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This is the inverse of `RemoteProperty<T>`.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions. See\n * https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype LocalProperty<T> = T extends Function | ProxyMarked\n  ? Local<T>\n  : Unpromisify<T>;\n\n/**\n * Proxies `T` if it is a `ProxyMarked`, clones it otherwise (as handled by structured cloning and transfer handlers).\n */\nexport type ProxyOrClone<T> = T extends ProxyMarked ? Remote<T> : T;\n/**\n * Inverse of `ProxyOrClone<T>`.\n */\nexport type UnproxyOrClone<T> = T extends RemoteObject<ProxyMarked>\n  ? Local<T>\n  : T;\n\n/**\n * Takes the raw type of a remote object in the other thread and returns the type as it is visible to the local thread\n * when proxied with `Comlink.proxy()`.\n *\n * This does not handle call signatures, which is handled by the more general `Remote<T>` type.\n *\n * @template T The raw type of a remote object as seen in the other thread.\n */\nexport type RemoteObject<T> = { [P in keyof T]: RemoteProperty<T[P]> };\n/**\n * Takes the type of an object as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This does not handle call signatures, which is handled by the more general `Local<T>` type.\n *\n * This is the inverse of `RemoteObject<T>`.\n *\n * @template T The type of a proxied object.\n */\nexport type LocalObject<T> = { [P in keyof T]: LocalProperty<T[P]> };\n\n/**\n * Additional special comlink methods available on each proxy returned by `Comlink.wrap()`.\n */\nexport interface ProxyMethods {\n  [createEndpoint]: () => Promise<MessagePort>;\n  [releaseProxy]: () => void;\n}\n\n/**\n * Takes the raw type of a remote object, function or class in the other thread and returns the type as it is visible to\n * the local thread from the proxy return value of `Comlink.wrap()` or `Comlink.proxy()`.\n */\nexport type Remote<T> =\n  // Handle properties\n  RemoteObject<T> &\n    // Handle call signature (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: UnproxyOrClone<TArguments[I]> }\n        ) => Promisify<ProxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: UnproxyOrClone<TArguments[I]>;\n            }\n          ): Promisify<Remote<TInstance>>;\n        }\n      : unknown) &\n    // Include additional special comlink methods available on the proxy.\n    ProxyMethods;\n\n/**\n * Expresses that a type can be either a sync or async.\n */\ntype MaybePromise<T> = Promise<T> | T;\n\n/**\n * Takes the raw type of a remote object, function or class as a remote thread would see it through a proxy (e.g. when\n * passed in as a function argument) and returns the type the local thread has to supply.\n *\n * This is the inverse of `Remote<T>`. It takes a `Remote<T>` and returns its original input `T`.\n */\nexport type Local<T> =\n  // Omit the special proxy methods (they don't need to be supplied, comlink adds them)\n  Omit<LocalObject<T>, keyof ProxyMethods> &\n    // Handle call signatures (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: ProxyOrClone<TArguments[I]> }\n        ) => // The raw function could either be sync or async, but is always proxied automatically\n        MaybePromise<UnproxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: ProxyOrClone<TArguments[I]>;\n            }\n          ): // The raw constructor could either be sync or async, but is always proxied automatically\n          MaybePromise<Local<Unpromisify<TInstance>>>;\n        }\n      : unknown);\n\nconst isObject = (val: unknown): val is object =>\n  (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n\n/**\n * Customizes the serialization of certain values as determined by `canHandle()`.\n *\n * @template T The input type being handled by this transfer handler.\n * @template S The serialized type sent over the wire.\n */\nexport interface TransferHandler<T, S> {\n  /**\n   * Gets called for every value to determine whether this transfer handler\n   * should serialize the value, which includes checking that it is of the right\n   * type (but can perform checks beyond that as well).\n   */\n  canHandle(value: unknown): value is T;\n\n  /**\n   * Gets called with the value if `canHandle()` returned `true` to produce a\n   * value that can be sent in a message, consisting of structured-cloneable\n   * values and/or transferrable objects.\n   */\n  serialize(value: T): [S, Transferable[]];\n\n  /**\n   * Gets called to deserialize an incoming value that was serialized in the\n   * other thread with this transfer handler (known through the name it was\n   * registered under).\n   */\n  deserialize(value: S): T;\n}\n\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler: TransferHandler<object, MessagePort> = {\n  canHandle: (val): val is ProxyMarked =>\n    isObject(val) && (val as ProxyMarked)[proxyMarker],\n  serialize(obj) {\n    const { port1, port2 } = new MessageChannel();\n    expose(obj, port1);\n    return [port2, [port2]];\n  },\n  deserialize(port) {\n    port.start();\n    return wrap(port);\n  },\n};\n\ninterface ThrownValue {\n  [throwMarker]: unknown; // just needs to be present\n  value: unknown;\n}\ntype SerializedThrownValue =\n  | { isError: true; value: Error }\n  | { isError: false; value: unknown };\n\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler: TransferHandler<\n  ThrownValue,\n  SerializedThrownValue\n> = {\n  canHandle: (value): value is ThrownValue =>\n    isObject(value) && throwMarker in value,\n  serialize({ value }) {\n    let serialized: SerializedThrownValue;\n    if (value instanceof Error) {\n      serialized = {\n        isError: true,\n        value: {\n          message: value.message,\n          name: value.name,\n          stack: value.stack,\n        },\n      };\n    } else {\n      serialized = { isError: false, value };\n    }\n    return [serialized, []];\n  },\n  deserialize(serialized) {\n    if (serialized.isError) {\n      throw Object.assign(\n        new Error(serialized.value.message),\n        serialized.value\n      );\n    }\n    throw serialized.value;\n  },\n};\n\n/**\n * Allows customizing the serialization of certain values.\n */\nexport const transferHandlers = new Map<\n  string,\n  TransferHandler<unknown, unknown>\n>([\n  [\"proxy\", proxyTransferHandler],\n  [\"throw\", throwTransferHandler],\n]);\n\nfunction isAllowedOrigin(\n  allowedOrigins: (string | RegExp)[],\n  origin: string\n): boolean {\n  for (const allowedOrigin of allowedOrigins) {\n    if (origin === allowedOrigin || allowedOrigin === \"*\") {\n      return true;\n    }\n    if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function expose(\n  obj: any,\n  ep: Endpoint = globalThis as any,\n  allowedOrigins: (string | RegExp)[] = [\"*\"]\n) {\n  ep.addEventListener(\"message\", function callback(ev: MessageEvent) {\n    if (!ev || !ev.data) {\n      return;\n    }\n    if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n      console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n      return;\n    }\n    const { id, type, path } = {\n      path: [] as string[],\n      ...(ev.data as Message),\n    };\n    const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n    let returnValue;\n    try {\n      const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n      const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n      switch (type) {\n        case MessageType.GET:\n          {\n            returnValue = rawValue;\n          }\n          break;\n        case MessageType.SET:\n          {\n            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n            returnValue = true;\n          }\n          break;\n        case MessageType.APPLY:\n          {\n            returnValue = rawValue.apply(parent, argumentList);\n          }\n          break;\n        case MessageType.CONSTRUCT:\n          {\n            const value = new rawValue(...argumentList);\n            returnValue = proxy(value);\n          }\n          break;\n        case MessageType.ENDPOINT:\n          {\n            const { port1, port2 } = new MessageChannel();\n            expose(obj, port2);\n            returnValue = transfer(port1, [port1]);\n          }\n          break;\n        case MessageType.RELEASE:\n          {\n            returnValue = undefined;\n          }\n          break;\n        default:\n          return;\n      }\n    } catch (value) {\n      returnValue = { value, [throwMarker]: 0 };\n    }\n    Promise.resolve(returnValue)\n      .catch((value) => {\n        return { value, [throwMarker]: 0 };\n      })\n      .then((returnValue) => {\n        const [wireValue, transferables] = toWireValue(returnValue);\n        ep.postMessage({ ...wireValue, id }, transferables);\n        if (type === MessageType.RELEASE) {\n          // detach and deactive after sending release response above.\n          ep.removeEventListener(\"message\", callback as any);\n          closeEndPoint(ep);\n          if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n            obj[finalizer]();\n          }\n        }\n      })\n      .catch((error) => {\n        // Send Serialization Error To Caller\n        const [wireValue, transferables] = toWireValue({\n          value: new TypeError(\"Unserializable return value\"),\n          [throwMarker]: 0,\n        });\n        ep.postMessage({ ...wireValue, id }, transferables);\n      });\n  } as any);\n  if (ep.start) {\n    ep.start();\n  }\n}\n\nfunction isMessagePort(endpoint: Endpoint): endpoint is MessagePort {\n  return endpoint.constructor.name === \"MessagePort\";\n}\n\nfunction closeEndPoint(endpoint: Endpoint) {\n  if (isMessagePort(endpoint)) endpoint.close();\n}\n\nexport function wrap<T>(ep: Endpoint, target?: any): Remote<T> {\n  return createProxy<T>(ep, [], target) as any;\n}\n\nfunction throwIfProxyReleased(isReleased: boolean) {\n  if (isReleased) {\n    throw new Error(\"Proxy has been released and is not useable\");\n  }\n}\n\nfunction releaseEndpoint(ep: Endpoint) {\n  return requestResponseMessage(ep, {\n    type: MessageType.RELEASE,\n  }).then(() => {\n    closeEndPoint(ep);\n  });\n}\n\ninterface FinalizationRegistry<T> {\n  new (cb: (heldValue: T) => void): FinalizationRegistry<T>;\n  register(\n    weakItem: object,\n    heldValue: T,\n    unregisterToken?: object | undefined\n  ): void;\n  unregister(unregisterToken: object): void;\n}\ndeclare var FinalizationRegistry: FinalizationRegistry<Endpoint>;\n\nconst proxyCounter = new WeakMap<Endpoint, number>();\nconst proxyFinalizers =\n  \"FinalizationRegistry\" in globalThis &&\n  new FinalizationRegistry((ep: Endpoint) => {\n    const newCount = (proxyCounter.get(ep) || 0) - 1;\n    proxyCounter.set(ep, newCount);\n    if (newCount === 0) {\n      releaseEndpoint(ep);\n    }\n  });\n\nfunction registerProxy(proxy: object, ep: Endpoint) {\n  const newCount = (proxyCounter.get(ep) || 0) + 1;\n  proxyCounter.set(ep, newCount);\n  if (proxyFinalizers) {\n    proxyFinalizers.register(proxy, ep, proxy);\n  }\n}\n\nfunction unregisterProxy(proxy: object) {\n  if (proxyFinalizers) {\n    proxyFinalizers.unregister(proxy);\n  }\n}\n\nfunction createProxy<T>(\n  ep: Endpoint,\n  path: (string | number | symbol)[] = [],\n  target: object = function () {}\n): Remote<T> {\n  let isProxyReleased = false;\n  const proxy = new Proxy(target, {\n    get(_target, prop) {\n      throwIfProxyReleased(isProxyReleased);\n      if (prop === releaseProxy) {\n        return () => {\n          unregisterProxy(proxy);\n          releaseEndpoint(ep);\n          isProxyReleased = true;\n        };\n      }\n      if (prop === \"then\") {\n        if (path.length === 0) {\n          return { then: () => proxy };\n        }\n        const r = requestResponseMessage(ep, {\n          type: MessageType.GET,\n          path: path.map((p) => p.toString()),\n        }).then(fromWireValue);\n        return r.then.bind(r);\n      }\n      return createProxy(ep, [...path, prop]);\n    },\n    set(_target, prop, rawValue) {\n      throwIfProxyReleased(isProxyReleased);\n      // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n      // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n      const [value, transferables] = toWireValue(rawValue);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.SET,\n          path: [...path, prop].map((p) => p.toString()),\n          value,\n        },\n        transferables\n      ).then(fromWireValue) as any;\n    },\n    apply(_target, _thisArg, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const last = path[path.length - 1];\n      if ((last as any) === createEndpoint) {\n        return requestResponseMessage(ep, {\n          type: MessageType.ENDPOINT,\n        }).then(fromWireValue);\n      }\n      // We just pretend that `bind()` didn’t happen.\n      if (last === \"bind\") {\n        return createProxy(ep, path.slice(0, -1));\n      }\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.APPLY,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n    construct(_target, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.CONSTRUCT,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n  });\n  registerProxy(proxy, ep);\n  return proxy as any;\n}\n\nfunction myFlat<T>(arr: (T | T[])[]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\nfunction processArguments(argumentList: any[]): [WireValue[], Transferable[]] {\n  const processed = argumentList.map(toWireValue);\n  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\n\nconst transferCache = new WeakMap<any, Transferable[]>();\nexport function transfer<T>(obj: T, transfers: Transferable[]): T {\n  transferCache.set(obj, transfers);\n  return obj;\n}\n\nexport function proxy<T extends {}>(obj: T): T & ProxyMarked {\n  return Object.assign(obj, { [proxyMarker]: true }) as any;\n}\n\nexport function windowEndpoint(\n  w: PostMessageWithOrigin,\n  context: EventSource = globalThis,\n  targetOrigin = \"*\"\n): Endpoint {\n  return {\n    postMessage: (msg: any, transferables: Transferable[]) =>\n      w.postMessage(msg, targetOrigin, transferables),\n    addEventListener: context.addEventListener.bind(context),\n    removeEventListener: context.removeEventListener.bind(context),\n  };\n}\n\nfunction toWireValue(value: any): [WireValue, Transferable[]] {\n  for (const [name, handler] of transferHandlers) {\n    if (handler.canHandle(value)) {\n      const [serializedValue, transferables] = handler.serialize(value);\n      return [\n        {\n          type: WireValueType.HANDLER,\n          name,\n          value: serializedValue,\n        },\n        transferables,\n      ];\n    }\n  }\n  return [\n    {\n      type: WireValueType.RAW,\n      value,\n    },\n    transferCache.get(value) || [],\n  ];\n}\n\nfunction fromWireValue(value: WireValue): any {\n  switch (value.type) {\n    case WireValueType.HANDLER:\n      return transferHandlers.get(value.name)!.deserialize(value.value);\n    case WireValueType.RAW:\n      return value.value;\n  }\n}\n\nfunction requestResponseMessage(\n  ep: Endpoint,\n  msg: Message,\n  transfers?: Transferable[]\n): Promise<WireValue> {\n  return new Promise((resolve) => {\n    const id = generateUUID();\n    ep.addEventListener(\"message\", function l(ev: MessageEvent) {\n      if (!ev.data || !ev.data.id || ev.data.id !== id) {\n        return;\n      }\n      ep.removeEventListener(\"message\", l as any);\n      resolve(ev.data);\n    } as any);\n    if (ep.start) {\n      ep.start();\n    }\n    ep.postMessage({ id, ...msg }, transfers);\n  });\n}\n\nfunction generateUUID(): string {\n  return new Array(4)\n    .fill(0)\n    .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n    .join(\"-\");\n}\n","/// <reference types=\"emscripten\"/>\nimport { expose, transfer } from 'comlink';\nimport workerPromise from './sort';\nimport sharedArrayBufferWorkerPromise from './sort';\nimport { BufferPool } from './BufferPool';\nexport class WasmSorter {\n    constructor(vertexCount, globalBuffer) {\n        this.vertexCount = vertexCount;\n        this.globalBuffer = globalBuffer;\n        const combinedLength = this.calculateCombinedLength();\n        // we're double buffering, so 2 is the magic number here\n        this.bufferPool = new BufferPool(combinedLength, 2);\n    }\n    async load() {\n        const sharedABSupported = typeof SharedArrayBuffer !== 'undefined';\n        this.module = await (sharedABSupported ? sharedArrayBufferWorkerPromise() : workerPromise());\n        this.viewProjPtr = this.module._malloc(16 * Float32Array.BYTES_PER_ELEMENT);\n        this.globalBufferPtr = this.module._malloc(this.vertexCount * 32);\n        this.combinedPtr = this.module._malloc(this.calculateCombinedLength());\n        this.module.HEAPU8.set(this.globalBuffer, this.globalBufferPtr);\n    }\n    runSort(viewProj) {\n        this.module.HEAPF32.set(viewProj, this.viewProjPtr / Float32Array.BYTES_PER_ELEMENT);\n        this.module.runSort(this.viewProjPtr, this.globalBufferPtr, this.vertexCount, this.combinedPtr);\n        const byteStart = this.combinedPtr;\n        const byteLength = this.calculateCombinedLength();\n        const bufferToTransfer = this.bufferPool.getBuffer();\n        new Uint8Array(bufferToTransfer).set(new Uint8Array(this.module.HEAPU8.buffer, byteStart, byteLength));\n        return transfer(bufferToTransfer, [bufferToTransfer]);\n    }\n    returnBuffer(buffer) {\n        this.bufferPool.returnBuffer(buffer);\n    }\n    calculateCombinedLength() {\n        return 4 * 4 * this.vertexCount + 3 * 4 * this.vertexCount + 3 * 4 * this.vertexCount + 4 * 4 * this.vertexCount * Float32Array.BYTES_PER_ELEMENT;\n    }\n    dispose() {\n        if (this.module) {\n            this.module._free(this.viewProjPtr);\n            this.module._free(this.globalBufferPtr);\n            this.module._free(this.combinedPtr);\n        }\n    }\n}\nexpose(WasmSorter);\n","\nvar Module = (() => {\n  var _scriptDir = import.meta.url;\n  \n  return (\nfunction(moduleArg = {}) {\n\nvar Module=moduleArg;var readyPromiseResolve,readyPromiseReject;Module[\"ready\"]=new Promise((resolve,reject)=>{readyPromiseResolve=resolve;readyPromiseReject=reject});var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram=\"./this.program\";var quit_=(status,toThrow)=>{throw toThrow};var ENVIRONMENT_IS_WEB=typeof window==\"object\";var ENVIRONMENT_IS_WORKER=typeof importScripts==\"function\";var ENVIRONMENT_IS_NODE=typeof process==\"object\"&&typeof process.versions==\"object\"&&typeof process.versions.node==\"string\";var scriptDirectory=\"\";function locateFile(path){if(Module[\"locateFile\"]){return Module[\"locateFile\"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary;if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!=\"undefined\"&&document.currentScript){scriptDirectory=document.currentScript.src}if(_scriptDir){scriptDirectory=_scriptDir}if(scriptDirectory.indexOf(\"blob:\")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1)}else{scriptDirectory=\"\"}{read_=url=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);xhr.responseType=\"arraybuffer\";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=(url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,true);xhr.responseType=\"arraybuffer\";xhr.onload=()=>{if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}}else{}var out=Module[\"print\"]||console.log.bind(console);var err=Module[\"printErr\"]||console.error.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module[\"arguments\"])arguments_=Module[\"arguments\"];if(Module[\"thisProgram\"])thisProgram=Module[\"thisProgram\"];if(Module[\"quit\"])quit_=Module[\"quit\"];var wasmBinary;if(Module[\"wasmBinary\"])wasmBinary=Module[\"wasmBinary\"];if(typeof WebAssembly!=\"object\"){abort(\"no native wasm support detected\")}var wasmMemory;var ABORT=false;var EXITSTATUS;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateMemoryViews(){var b=wasmMemory.buffer;Module[\"HEAP8\"]=HEAP8=new Int8Array(b);Module[\"HEAP16\"]=HEAP16=new Int16Array(b);Module[\"HEAPU8\"]=HEAPU8=new Uint8Array(b);Module[\"HEAPU16\"]=HEAPU16=new Uint16Array(b);Module[\"HEAP32\"]=HEAP32=new Int32Array(b);Module[\"HEAPU32\"]=HEAPU32=new Uint32Array(b);Module[\"HEAPF32\"]=HEAPF32=new Float32Array(b);Module[\"HEAPF64\"]=HEAPF64=new Float64Array(b)}var __ATPRERUN__=[];var __ATINIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;function preRun(){if(Module[\"preRun\"]){if(typeof Module[\"preRun\"]==\"function\")Module[\"preRun\"]=[Module[\"preRun\"]];while(Module[\"preRun\"].length){addOnPreRun(Module[\"preRun\"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function postRun(){if(Module[\"postRun\"]){if(typeof Module[\"postRun\"]==\"function\")Module[\"postRun\"]=[Module[\"postRun\"]];while(Module[\"postRun\"].length){addOnPostRun(Module[\"postRun\"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module[\"monitorRunDependencies\"]){Module[\"monitorRunDependencies\"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module[\"monitorRunDependencies\"]){Module[\"monitorRunDependencies\"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}function abort(what){if(Module[\"onAbort\"]){Module[\"onAbort\"](what)}what=\"Aborted(\"+what+\")\";err(what);ABORT=true;EXITSTATUS=1;what+=\". Build with -sASSERTIONS for more info.\";var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);throw e}var dataURIPrefix=\"data:application/octet-stream;base64,\";var isDataURI=filename=>filename.startsWith(dataURIPrefix);var wasmBinaryFile;if(Module[\"locateFile\"]){wasmBinaryFile=\"sort.wasm\";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}}else{wasmBinaryFile=new URL(\"sort.wasm\",import.meta.url).href}function getBinarySync(file){if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw\"both async and sync fetching of the wasm failed\"}function getBinaryPromise(binaryFile){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch==\"function\"){return fetch(binaryFile,{credentials:\"same-origin\"}).then(response=>{if(!response[\"ok\"]){throw\"failed to load wasm binary file at '\"+binaryFile+\"'\"}return response[\"arrayBuffer\"]()}).catch(()=>getBinarySync(binaryFile))}}return Promise.resolve().then(()=>getBinarySync(binaryFile))}function instantiateArrayBuffer(binaryFile,imports,receiver){return getBinaryPromise(binaryFile).then(binary=>WebAssembly.instantiate(binary,imports)).then(instance=>instance).then(receiver,reason=>{err(`failed to asynchronously prepare wasm: ${reason}`);abort(reason)})}function instantiateAsync(binary,binaryFile,imports,callback){if(!binary&&typeof WebAssembly.instantiateStreaming==\"function\"&&!isDataURI(binaryFile)&&typeof fetch==\"function\"){return fetch(binaryFile,{credentials:\"same-origin\"}).then(response=>{var result=WebAssembly.instantiateStreaming(response,imports);return result.then(callback,function(reason){err(`wasm streaming compile failed: ${reason}`);err(\"falling back to ArrayBuffer instantiation\");return instantiateArrayBuffer(binaryFile,imports,callback)})})}return instantiateArrayBuffer(binaryFile,imports,callback)}function createWasm(){var info={\"a\":wasmImports};function receiveInstance(instance,module){wasmExports=instance.exports;wasmMemory=wasmExports[\"o\"];updateMemoryViews();wasmTable=wasmExports[\"s\"];addOnInit(wasmExports[\"p\"]);removeRunDependency(\"wasm-instantiate\");return wasmExports}addRunDependency(\"wasm-instantiate\");function receiveInstantiationResult(result){receiveInstance(result[\"instance\"])}if(Module[\"instantiateWasm\"]){try{return Module[\"instantiateWasm\"](info,receiveInstance)}catch(e){err(`Module.instantiateWasm callback failed with error: ${e}`);readyPromiseReject(e)}}instantiateAsync(wasmBinary,wasmBinaryFile,info,receiveInstantiationResult).catch(readyPromiseReject);return{}}var callRuntimeCallbacks=callbacks=>{while(callbacks.length>0){callbacks.shift()(Module)}};var noExitRuntime=Module[\"noExitRuntime\"]||true;function ExceptionInfo(excPtr){this.excPtr=excPtr;this.ptr=excPtr-24;this.set_type=function(type){HEAPU32[this.ptr+4>>2]=type};this.get_type=function(){return HEAPU32[this.ptr+4>>2]};this.set_destructor=function(destructor){HEAPU32[this.ptr+8>>2]=destructor};this.get_destructor=function(){return HEAPU32[this.ptr+8>>2]};this.set_caught=function(caught){caught=caught?1:0;HEAP8[this.ptr+12>>0]=caught};this.get_caught=function(){return HEAP8[this.ptr+12>>0]!=0};this.set_rethrown=function(rethrown){rethrown=rethrown?1:0;HEAP8[this.ptr+13>>0]=rethrown};this.get_rethrown=function(){return HEAP8[this.ptr+13>>0]!=0};this.init=function(type,destructor){this.set_adjusted_ptr(0);this.set_type(type);this.set_destructor(destructor)};this.set_adjusted_ptr=function(adjustedPtr){HEAPU32[this.ptr+16>>2]=adjustedPtr};this.get_adjusted_ptr=function(){return HEAPU32[this.ptr+16>>2]};this.get_exception_ptr=function(){var isPointer=___cxa_is_pointer_type(this.get_type());if(isPointer){return HEAPU32[this.excPtr>>2]}var adjusted=this.get_adjusted_ptr();if(adjusted!==0)return adjusted;return this.excPtr}}var exceptionLast=0;var uncaughtExceptionCount=0;var ___cxa_throw=(ptr,type,destructor)=>{var info=new ExceptionInfo(ptr);info.init(type,destructor);exceptionLast=ptr;uncaughtExceptionCount++;throw exceptionLast};var __embind_register_bigint=(primitiveType,name,size,minRange,maxRange)=>{};var embind_init_charCodes=()=>{var codes=new Array(256);for(var i=0;i<256;++i){codes[i]=String.fromCharCode(i)}embind_charCodes=codes};var embind_charCodes;var readLatin1String=ptr=>{var ret=\"\";var c=ptr;while(HEAPU8[c]){ret+=embind_charCodes[HEAPU8[c++]]}return ret};var awaitingDependencies={};var registeredTypes={};var typeDependencies={};var BindingError;var throwBindingError=message=>{throw new BindingError(message)};var InternalError;var throwInternalError=message=>{throw new InternalError(message)};var whenDependentTypesAreResolved=(myTypes,dependentTypes,getTypeConverters)=>{myTypes.forEach(function(type){typeDependencies[type]=dependentTypes});function onComplete(typeConverters){var myTypeConverters=getTypeConverters(typeConverters);if(myTypeConverters.length!==myTypes.length){throwInternalError(\"Mismatched type converter count\")}for(var i=0;i<myTypes.length;++i){registerType(myTypes[i],myTypeConverters[i])}}var typeConverters=new Array(dependentTypes.length);var unregisteredTypes=[];var registered=0;dependentTypes.forEach((dt,i)=>{if(registeredTypes.hasOwnProperty(dt)){typeConverters[i]=registeredTypes[dt]}else{unregisteredTypes.push(dt);if(!awaitingDependencies.hasOwnProperty(dt)){awaitingDependencies[dt]=[]}awaitingDependencies[dt].push(()=>{typeConverters[i]=registeredTypes[dt];++registered;if(registered===unregisteredTypes.length){onComplete(typeConverters)}})}});if(0===unregisteredTypes.length){onComplete(typeConverters)}};function sharedRegisterType(rawType,registeredInstance,options={}){var name=registeredInstance.name;if(!rawType){throwBindingError(`type \"${name}\" must have a positive integer typeid pointer`)}if(registeredTypes.hasOwnProperty(rawType)){if(options.ignoreDuplicateRegistrations){return}else{throwBindingError(`Cannot register type '${name}' twice`)}}registeredTypes[rawType]=registeredInstance;delete typeDependencies[rawType];if(awaitingDependencies.hasOwnProperty(rawType)){var callbacks=awaitingDependencies[rawType];delete awaitingDependencies[rawType];callbacks.forEach(cb=>cb())}}function registerType(rawType,registeredInstance,options={}){if(!(\"argPackAdvance\"in registeredInstance)){throw new TypeError(\"registerType registeredInstance requires argPackAdvance\")}return sharedRegisterType(rawType,registeredInstance,options)}var GenericWireTypeSize=8;var __embind_register_bool=(rawType,name,trueValue,falseValue)=>{name=readLatin1String(name);registerType(rawType,{name:name,\"fromWireType\":function(wt){return!!wt},\"toWireType\":function(destructors,o){return o?trueValue:falseValue},\"argPackAdvance\":GenericWireTypeSize,\"readValueFromPointer\":function(pointer){return this[\"fromWireType\"](HEAPU8[pointer])},destructorFunction:null})};function handleAllocatorInit(){Object.assign(HandleAllocator.prototype,{get(id){return this.allocated[id]},has(id){return this.allocated[id]!==undefined},allocate(handle){var id=this.freelist.pop()||this.allocated.length;this.allocated[id]=handle;return id},free(id){this.allocated[id]=undefined;this.freelist.push(id)}})}function HandleAllocator(){this.allocated=[undefined];this.freelist=[]}var emval_handles=new HandleAllocator;var __emval_decref=handle=>{if(handle>=emval_handles.reserved&&0===--emval_handles.get(handle).refcount){emval_handles.free(handle)}};var count_emval_handles=()=>{var count=0;for(var i=emval_handles.reserved;i<emval_handles.allocated.length;++i){if(emval_handles.allocated[i]!==undefined){++count}}return count};var init_emval=()=>{emval_handles.allocated.push({value:undefined},{value:null},{value:true},{value:false});emval_handles.reserved=emval_handles.allocated.length;Module[\"count_emval_handles\"]=count_emval_handles};var Emval={toValue:handle=>{if(!handle){throwBindingError(\"Cannot use deleted val. handle = \"+handle)}return emval_handles.get(handle).value},toHandle:value=>{switch(value){case undefined:return 1;case null:return 2;case true:return 3;case false:return 4;default:{return emval_handles.allocate({refcount:1,value:value})}}}};function simpleReadValueFromPointer(pointer){return this[\"fromWireType\"](HEAP32[pointer>>2])}var __embind_register_emval=(rawType,name)=>{name=readLatin1String(name);registerType(rawType,{name:name,\"fromWireType\":handle=>{var rv=Emval.toValue(handle);__emval_decref(handle);return rv},\"toWireType\":(destructors,value)=>Emval.toHandle(value),\"argPackAdvance\":GenericWireTypeSize,\"readValueFromPointer\":simpleReadValueFromPointer,destructorFunction:null})};var floatReadValueFromPointer=(name,width)=>{switch(width){case 4:return function(pointer){return this[\"fromWireType\"](HEAPF32[pointer>>2])};case 8:return function(pointer){return this[\"fromWireType\"](HEAPF64[pointer>>3])};default:throw new TypeError(`invalid float width (${width}): ${name}`)}};var __embind_register_float=(rawType,name,size)=>{name=readLatin1String(name);registerType(rawType,{name:name,\"fromWireType\":value=>value,\"toWireType\":(destructors,value)=>value,\"argPackAdvance\":GenericWireTypeSize,\"readValueFromPointer\":floatReadValueFromPointer(name,size),destructorFunction:null})};var createNamedFunction=(name,body)=>Object.defineProperty(body,\"name\",{value:name});var runDestructors=destructors=>{while(destructors.length){var ptr=destructors.pop();var del=destructors.pop();del(ptr)}};function newFunc(constructor,argumentList){if(!(constructor instanceof Function)){throw new TypeError(`new_ called with constructor type ${typeof constructor} which is not a function`)}var dummy=createNamedFunction(constructor.name||\"unknownFunctionName\",function(){});dummy.prototype=constructor.prototype;var obj=new dummy;var r=constructor.apply(obj,argumentList);return r instanceof Object?r:obj}function craftInvokerFunction(humanName,argTypes,classType,cppInvokerFunc,cppTargetFunc,isAsync){var argCount=argTypes.length;if(argCount<2){throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\")}var isClassMethodFunc=argTypes[1]!==null&&classType!==null;var needsDestructorStack=false;for(var i=1;i<argTypes.length;++i){if(argTypes[i]!==null&&argTypes[i].destructorFunction===undefined){needsDestructorStack=true;break}}var returns=argTypes[0].name!==\"void\";var argsList=\"\";var argsListWired=\"\";for(var i=0;i<argCount-2;++i){argsList+=(i!==0?\", \":\"\")+\"arg\"+i;argsListWired+=(i!==0?\", \":\"\")+\"arg\"+i+\"Wired\"}var invokerFnBody=`\\n        return function (${argsList}) {\\n        if (arguments.length !== ${argCount-2}) {\\n          throwBindingError('function ${humanName} called with ' + arguments.length + ' arguments, expected ${argCount-2}');\\n        }`;if(needsDestructorStack){invokerFnBody+=\"var destructors = [];\\n\"}var dtorStack=needsDestructorStack?\"destructors\":\"null\";var args1=[\"throwBindingError\",\"invoker\",\"fn\",\"runDestructors\",\"retType\",\"classParam\"];var args2=[throwBindingError,cppInvokerFunc,cppTargetFunc,runDestructors,argTypes[0],argTypes[1]];if(isClassMethodFunc){invokerFnBody+=\"var thisWired = classParam.toWireType(\"+dtorStack+\", this);\\n\"}for(var i=0;i<argCount-2;++i){invokerFnBody+=\"var arg\"+i+\"Wired = argType\"+i+\".toWireType(\"+dtorStack+\", arg\"+i+\"); // \"+argTypes[i+2].name+\"\\n\";args1.push(\"argType\"+i);args2.push(argTypes[i+2])}if(isClassMethodFunc){argsListWired=\"thisWired\"+(argsListWired.length>0?\", \":\"\")+argsListWired}invokerFnBody+=(returns||isAsync?\"var rv = \":\"\")+\"invoker(fn\"+(argsListWired.length>0?\", \":\"\")+argsListWired+\");\\n\";if(needsDestructorStack){invokerFnBody+=\"runDestructors(destructors);\\n\"}else{for(var i=isClassMethodFunc?1:2;i<argTypes.length;++i){var paramName=i===1?\"thisWired\":\"arg\"+(i-2)+\"Wired\";if(argTypes[i].destructorFunction!==null){invokerFnBody+=paramName+\"_dtor(\"+paramName+\"); // \"+argTypes[i].name+\"\\n\";args1.push(paramName+\"_dtor\");args2.push(argTypes[i].destructorFunction)}}}if(returns){invokerFnBody+=\"var ret = retType.fromWireType(rv);\\n\"+\"return ret;\\n\"}else{}invokerFnBody+=\"}\\n\";args1.push(invokerFnBody);var invokerFn=newFunc(Function,args1).apply(null,args2);return createNamedFunction(humanName,invokerFn)}var ensureOverloadTable=(proto,methodName,humanName)=>{if(undefined===proto[methodName].overloadTable){var prevFunc=proto[methodName];proto[methodName]=function(){if(!proto[methodName].overloadTable.hasOwnProperty(arguments.length)){throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${arguments.length}) - expects one of (${proto[methodName].overloadTable})!`)}return proto[methodName].overloadTable[arguments.length].apply(this,arguments)};proto[methodName].overloadTable=[];proto[methodName].overloadTable[prevFunc.argCount]=prevFunc}};var exposePublicSymbol=(name,value,numArguments)=>{if(Module.hasOwnProperty(name)){if(undefined===numArguments||undefined!==Module[name].overloadTable&&undefined!==Module[name].overloadTable[numArguments]){throwBindingError(`Cannot register public name '${name}' twice`)}ensureOverloadTable(Module,name,name);if(Module.hasOwnProperty(numArguments)){throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`)}Module[name].overloadTable[numArguments]=value}else{Module[name]=value;if(undefined!==numArguments){Module[name].numArguments=numArguments}}};var heap32VectorToArray=(count,firstElement)=>{var array=[];for(var i=0;i<count;i++){array.push(HEAPU32[firstElement+i*4>>2])}return array};var replacePublicSymbol=(name,value,numArguments)=>{if(!Module.hasOwnProperty(name)){throwInternalError(\"Replacing nonexistant public symbol\")}if(undefined!==Module[name].overloadTable&&undefined!==numArguments){Module[name].overloadTable[numArguments]=value}else{Module[name]=value;Module[name].argCount=numArguments}};var dynCallLegacy=(sig,ptr,args)=>{var f=Module[\"dynCall_\"+sig];return args&&args.length?f.apply(null,[ptr].concat(args)):f.call(null,ptr)};var wasmTableMirror=[];var wasmTable;var getWasmTableEntry=funcPtr=>{var func=wasmTableMirror[funcPtr];if(!func){if(funcPtr>=wasmTableMirror.length)wasmTableMirror.length=funcPtr+1;wasmTableMirror[funcPtr]=func=wasmTable.get(funcPtr)}return func};var dynCall=(sig,ptr,args)=>{if(sig.includes(\"j\")){return dynCallLegacy(sig,ptr,args)}var rtn=getWasmTableEntry(ptr).apply(null,args);return rtn};var getDynCaller=(sig,ptr)=>{var argCache=[];return function(){argCache.length=0;Object.assign(argCache,arguments);return dynCall(sig,ptr,argCache)}};var embind__requireFunction=(signature,rawFunction)=>{signature=readLatin1String(signature);function makeDynCaller(){if(signature.includes(\"j\")){return getDynCaller(signature,rawFunction)}return getWasmTableEntry(rawFunction)}var fp=makeDynCaller();if(typeof fp!=\"function\"){throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`)}return fp};var extendError=(baseErrorType,errorName)=>{var errorClass=createNamedFunction(errorName,function(message){this.name=errorName;this.message=message;var stack=new Error(message).stack;if(stack!==undefined){this.stack=this.toString()+\"\\n\"+stack.replace(/^Error(:[^\\n]*)?\\n/,\"\")}});errorClass.prototype=Object.create(baseErrorType.prototype);errorClass.prototype.constructor=errorClass;errorClass.prototype.toString=function(){if(this.message===undefined){return this.name}else{return`${this.name}: ${this.message}`}};return errorClass};var UnboundTypeError;var getTypeName=type=>{var ptr=___getTypeName(type);var rv=readLatin1String(ptr);_free(ptr);return rv};var throwUnboundTypeError=(message,types)=>{var unboundTypes=[];var seen={};function visit(type){if(seen[type]){return}if(registeredTypes[type]){return}if(typeDependencies[type]){typeDependencies[type].forEach(visit);return}unboundTypes.push(type);seen[type]=true}types.forEach(visit);throw new UnboundTypeError(`${message}: `+unboundTypes.map(getTypeName).join([\", \"]))};var getFunctionName=signature=>{signature=signature.trim();const argsIndex=signature.indexOf(\"(\");if(argsIndex!==-1){return signature.substr(0,argsIndex)}else{return signature}};var __embind_register_function=(name,argCount,rawArgTypesAddr,signature,rawInvoker,fn,isAsync)=>{var argTypes=heap32VectorToArray(argCount,rawArgTypesAddr);name=readLatin1String(name);name=getFunctionName(name);rawInvoker=embind__requireFunction(signature,rawInvoker);exposePublicSymbol(name,function(){throwUnboundTypeError(`Cannot call ${name} due to unbound types`,argTypes)},argCount-1);whenDependentTypesAreResolved([],argTypes,function(argTypes){var invokerArgsArray=[argTypes[0],null].concat(argTypes.slice(1));replacePublicSymbol(name,craftInvokerFunction(name,invokerArgsArray,null,rawInvoker,fn,isAsync),argCount-1);return[]})};var integerReadValueFromPointer=(name,width,signed)=>{switch(width){case 1:return signed?pointer=>HEAP8[pointer>>0]:pointer=>HEAPU8[pointer>>0];case 2:return signed?pointer=>HEAP16[pointer>>1]:pointer=>HEAPU16[pointer>>1];case 4:return signed?pointer=>HEAP32[pointer>>2]:pointer=>HEAPU32[pointer>>2];default:throw new TypeError(`invalid integer width (${width}): ${name}`)}};var __embind_register_integer=(primitiveType,name,size,minRange,maxRange)=>{name=readLatin1String(name);if(maxRange===-1){maxRange=4294967295}var fromWireType=value=>value;if(minRange===0){var bitshift=32-8*size;fromWireType=value=>value<<bitshift>>>bitshift}var isUnsignedType=name.includes(\"unsigned\");var checkAssertions=(value,toTypeName)=>{};var toWireType;if(isUnsignedType){toWireType=function(destructors,value){checkAssertions(value,this.name);return value>>>0}}else{toWireType=function(destructors,value){checkAssertions(value,this.name);return value}}registerType(primitiveType,{name:name,\"fromWireType\":fromWireType,\"toWireType\":toWireType,\"argPackAdvance\":GenericWireTypeSize,\"readValueFromPointer\":integerReadValueFromPointer(name,size,minRange!==0),destructorFunction:null})};var __embind_register_memory_view=(rawType,dataTypeIndex,name)=>{var typeMapping=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];var TA=typeMapping[dataTypeIndex];function decodeMemoryView(handle){var size=HEAPU32[handle>>2];var data=HEAPU32[handle+4>>2];return new TA(HEAP8.buffer,data,size)}name=readLatin1String(name);registerType(rawType,{name:name,\"fromWireType\":decodeMemoryView,\"argPackAdvance\":GenericWireTypeSize,\"readValueFromPointer\":decodeMemoryView},{ignoreDuplicateRegistrations:true})};function readPointer(pointer){return this[\"fromWireType\"](HEAPU32[pointer>>2])}var stringToUTF8Array=(str,heap,outIdx,maxBytesToWrite)=>{if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}}heap[outIdx]=0;return outIdx-startIdx};var stringToUTF8=(str,outPtr,maxBytesToWrite)=>stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite);var lengthBytesUTF8=str=>{var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++}else if(c<=2047){len+=2}else if(c>=55296&&c<=57343){len+=4;++i}else{len+=3}}return len};var UTF8Decoder=typeof TextDecoder!=\"undefined\"?new TextDecoder(\"utf8\"):undefined;var UTF8ArrayToString=(heapOrArray,idx,maxBytesToRead)=>{var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}var str=\"\";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}return str};var UTF8ToString=(ptr,maxBytesToRead)=>ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):\"\";var __embind_register_std_string=(rawType,name)=>{name=readLatin1String(name);var stdStringIsUTF8=name===\"std::string\";registerType(rawType,{name:name,\"fromWireType\"(value){var length=HEAPU32[value>>2];var payload=value+4;var str;if(stdStringIsUTF8){var decodeStartPtr=payload;for(var i=0;i<=length;++i){var currentBytePtr=payload+i;if(i==length||HEAPU8[currentBytePtr]==0){var maxRead=currentBytePtr-decodeStartPtr;var stringSegment=UTF8ToString(decodeStartPtr,maxRead);if(str===undefined){str=stringSegment}else{str+=String.fromCharCode(0);str+=stringSegment}decodeStartPtr=currentBytePtr+1}}}else{var a=new Array(length);for(var i=0;i<length;++i){a[i]=String.fromCharCode(HEAPU8[payload+i])}str=a.join(\"\")}_free(value);return str},\"toWireType\"(destructors,value){if(value instanceof ArrayBuffer){value=new Uint8Array(value)}var length;var valueIsOfTypeString=typeof value==\"string\";if(!(valueIsOfTypeString||value instanceof Uint8Array||value instanceof Uint8ClampedArray||value instanceof Int8Array)){throwBindingError(\"Cannot pass non-string to std::string\")}if(stdStringIsUTF8&&valueIsOfTypeString){length=lengthBytesUTF8(value)}else{length=value.length}var base=_malloc(4+length+1);var ptr=base+4;HEAPU32[base>>2]=length;if(stdStringIsUTF8&&valueIsOfTypeString){stringToUTF8(value,ptr,length+1)}else{if(valueIsOfTypeString){for(var i=0;i<length;++i){var charCode=value.charCodeAt(i);if(charCode>255){_free(ptr);throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\")}HEAPU8[ptr+i]=charCode}}else{for(var i=0;i<length;++i){HEAPU8[ptr+i]=value[i]}}}if(destructors!==null){destructors.push(_free,base)}return base},\"argPackAdvance\":GenericWireTypeSize,\"readValueFromPointer\":readPointer,destructorFunction(ptr){_free(ptr)}})};var UTF16Decoder=typeof TextDecoder!=\"undefined\"?new TextDecoder(\"utf-16le\"):undefined;var UTF16ToString=(ptr,maxBytesToRead)=>{var endPtr=ptr;var idx=endPtr>>1;var maxIdx=idx+maxBytesToRead/2;while(!(idx>=maxIdx)&&HEAPU16[idx])++idx;endPtr=idx<<1;if(endPtr-ptr>32&&UTF16Decoder)return UTF16Decoder.decode(HEAPU8.subarray(ptr,endPtr));var str=\"\";for(var i=0;!(i>=maxBytesToRead/2);++i){var codeUnit=HEAP16[ptr+i*2>>1];if(codeUnit==0)break;str+=String.fromCharCode(codeUnit)}return str};var stringToUTF16=(str,outPtr,maxBytesToWrite)=>{if(maxBytesToWrite===undefined){maxBytesToWrite=2147483647}if(maxBytesToWrite<2)return 0;maxBytesToWrite-=2;var startPtr=outPtr;var numCharsToWrite=maxBytesToWrite<str.length*2?maxBytesToWrite/2:str.length;for(var i=0;i<numCharsToWrite;++i){var codeUnit=str.charCodeAt(i);HEAP16[outPtr>>1]=codeUnit;outPtr+=2}HEAP16[outPtr>>1]=0;return outPtr-startPtr};var lengthBytesUTF16=str=>str.length*2;var UTF32ToString=(ptr,maxBytesToRead)=>{var i=0;var str=\"\";while(!(i>=maxBytesToRead/4)){var utf32=HEAP32[ptr+i*4>>2];if(utf32==0)break;++i;if(utf32>=65536){var ch=utf32-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}else{str+=String.fromCharCode(utf32)}}return str};var stringToUTF32=(str,outPtr,maxBytesToWrite)=>{if(maxBytesToWrite===undefined){maxBytesToWrite=2147483647}if(maxBytesToWrite<4)return 0;var startPtr=outPtr;var endPtr=startPtr+maxBytesToWrite-4;for(var i=0;i<str.length;++i){var codeUnit=str.charCodeAt(i);if(codeUnit>=55296&&codeUnit<=57343){var trailSurrogate=str.charCodeAt(++i);codeUnit=65536+((codeUnit&1023)<<10)|trailSurrogate&1023}HEAP32[outPtr>>2]=codeUnit;outPtr+=4;if(outPtr+4>endPtr)break}HEAP32[outPtr>>2]=0;return outPtr-startPtr};var lengthBytesUTF32=str=>{var len=0;for(var i=0;i<str.length;++i){var codeUnit=str.charCodeAt(i);if(codeUnit>=55296&&codeUnit<=57343)++i;len+=4}return len};var __embind_register_std_wstring=(rawType,charSize,name)=>{name=readLatin1String(name);var decodeString,encodeString,getHeap,lengthBytesUTF,shift;if(charSize===2){decodeString=UTF16ToString;encodeString=stringToUTF16;lengthBytesUTF=lengthBytesUTF16;getHeap=()=>HEAPU16;shift=1}else if(charSize===4){decodeString=UTF32ToString;encodeString=stringToUTF32;lengthBytesUTF=lengthBytesUTF32;getHeap=()=>HEAPU32;shift=2}registerType(rawType,{name:name,\"fromWireType\":value=>{var length=HEAPU32[value>>2];var HEAP=getHeap();var str;var decodeStartPtr=value+4;for(var i=0;i<=length;++i){var currentBytePtr=value+4+i*charSize;if(i==length||HEAP[currentBytePtr>>shift]==0){var maxReadBytes=currentBytePtr-decodeStartPtr;var stringSegment=decodeString(decodeStartPtr,maxReadBytes);if(str===undefined){str=stringSegment}else{str+=String.fromCharCode(0);str+=stringSegment}decodeStartPtr=currentBytePtr+charSize}}_free(value);return str},\"toWireType\":(destructors,value)=>{if(!(typeof value==\"string\")){throwBindingError(`Cannot pass non-string to C++ string type ${name}`)}var length=lengthBytesUTF(value);var ptr=_malloc(4+length+charSize);HEAPU32[ptr>>2]=length>>shift;encodeString(value,ptr+4,length+charSize);if(destructors!==null){destructors.push(_free,ptr)}return ptr},\"argPackAdvance\":GenericWireTypeSize,\"readValueFromPointer\":simpleReadValueFromPointer,destructorFunction(ptr){_free(ptr)}})};var __embind_register_void=(rawType,name)=>{name=readLatin1String(name);registerType(rawType,{isVoid:true,name:name,\"argPackAdvance\":0,\"fromWireType\":()=>undefined,\"toWireType\":(destructors,o)=>undefined})};var _abort=()=>{abort(\"\")};var _emscripten_memcpy_js=(dest,src,num)=>HEAPU8.copyWithin(dest,src,src+num);var getHeapMax=()=>2147483648;var growMemory=size=>{var b=wasmMemory.buffer;var pages=(size-b.byteLength+65535)/65536;try{wasmMemory.grow(pages);updateMemoryViews();return 1}catch(e){}};var _emscripten_resize_heap=requestedSize=>{var oldSize=HEAPU8.length;requestedSize>>>=0;var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}var alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=growMemory(newSize);if(replacement){return true}}return false};embind_init_charCodes();BindingError=Module[\"BindingError\"]=class BindingError extends Error{constructor(message){super(message);this.name=\"BindingError\"}};InternalError=Module[\"InternalError\"]=class InternalError extends Error{constructor(message){super(message);this.name=\"InternalError\"}};handleAllocatorInit();init_emval();UnboundTypeError=Module[\"UnboundTypeError\"]=extendError(Error,\"UnboundTypeError\");var wasmImports={n:___cxa_throw,k:__embind_register_bigint,i:__embind_register_bool,h:__embind_register_emval,d:__embind_register_float,g:__embind_register_function,b:__embind_register_integer,a:__embind_register_memory_view,e:__embind_register_std_string,c:__embind_register_std_wstring,j:__embind_register_void,f:_abort,m:_emscripten_memcpy_js,l:_emscripten_resize_heap};var wasmExports=createWasm();var ___wasm_call_ctors=()=>(___wasm_call_ctors=wasmExports[\"p\"])();var ___getTypeName=a0=>(___getTypeName=wasmExports[\"q\"])(a0);var ___errno_location=()=>(___errno_location=wasmExports[\"__errno_location\"])();var _malloc=Module[\"_malloc\"]=a0=>(_malloc=Module[\"_malloc\"]=wasmExports[\"r\"])(a0);var _free=Module[\"_free\"]=a0=>(_free=Module[\"_free\"]=wasmExports[\"t\"])(a0);var ___cxa_increment_exception_refcount=a0=>(___cxa_increment_exception_refcount=wasmExports[\"__cxa_increment_exception_refcount\"])(a0);var ___cxa_is_pointer_type=a0=>(___cxa_is_pointer_type=wasmExports[\"u\"])(a0);var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function run(){if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module[\"calledRun\"]=true;if(ABORT)return;initRuntime();readyPromiseResolve(Module);if(Module[\"onRuntimeInitialized\"])Module[\"onRuntimeInitialized\"]();postRun()}if(Module[\"setStatus\"]){Module[\"setStatus\"](\"Running...\");setTimeout(function(){setTimeout(function(){Module[\"setStatus\"](\"\")},1);doRun()},1)}else{doRun()}}if(Module[\"preInit\"]){if(typeof Module[\"preInit\"]==\"function\")Module[\"preInit\"]=[Module[\"preInit\"]];while(Module[\"preInit\"].length>0){Module[\"preInit\"].pop()()}}run();\n\n\n  return moduleArg.ready\n}\n);\n})();\n;\nexport default Module;","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","module.exports = new __parcel__URL__(\"sort.594a65d3.wasm\").toString();","export class BufferPool {\n    constructor(bufferSize, initialPoolSize = 0) {\n        this.bufferSize = bufferSize;\n        this.pool = [];\n        this.initPool(initialPoolSize);\n    }\n    initPool(initialPoolSize) {\n        for (let i = 0; i < initialPoolSize; i++) {\n            this.pool.push(new ArrayBuffer(this.bufferSize));\n        }\n    }\n    getBuffer() {\n        if (this.pool.length > 0) {\n            return this.pool.pop();\n        }\n        else {\n            return new ArrayBuffer(this.bufferSize);\n        }\n    }\n    returnBuffer(buffer) {\n        if (buffer.byteLength === this.bufferSize) {\n            this.pool.push(buffer);\n        }\n    }\n}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","_scriptDir","$cfae44f0dfdf62c0$var$cachedSetTimeout","$cfae44f0dfdf62c0$var$cachedClearTimeout","$cfae44f0dfdf62c0$var$currentQueue","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$0e112480d1414235$export$9b7f6e342a8cbd38","$0e112480d1414235$export$4997ffc0176396a6","$0e112480d1414235$export$c9b234447cf4ef7c","$0e112480d1414235$export$be5234c0b764b6e0","Symbol","$0e112480d1414235$export$39fb953702b7fcd7","$0e112480d1414235$export$89981d4b8d9f48aa","$0e112480d1414235$export$ddc31dfe7c269837","$0e112480d1414235$var$throwMarker","$0e112480d1414235$var$isObject","val","$0e112480d1414235$export$ab8f1c00731ee83e","Map","canHandle","serialize","obj","port1","port2","MessageChannel","deserialize","port","start","value","isError","message","name","stack","serialized","assign","ep","allowedOrigins","addEventListener","callback","ev","returnValue","data","$0e112480d1414235$var$isAllowedOrigin","origin","allowedOrigin","RegExp","test","console","warn","type","path","argumentList","map","$0e112480d1414235$var$fromWireValue","parent","slice","reduce","prop","rawValue","apply","undefined","Promise","resolve","catch","then","wireValue","transferables","$0e112480d1414235$var$toWireValue","postMessage","removeEventListener","$0e112480d1414235$var$closeEndPoint","error","TypeError","endpoint","constructor","close","target","$0e112480d1414235$var$createProxy","isProxyReleased","proxy","Proxy","_target","$0e112480d1414235$var$throwIfProxyReleased","$0e112480d1414235$var$proxyFinalizers","unregister","$0e112480d1414235$var$releaseEndpoint","length","r","$0e112480d1414235$var$requestResponseMessage","p","toString","bind","_thisArg","rawArgumentList","last","$0e112480d1414235$var$processArguments","construct","$0e112480d1414235$var$registerProxy","newCount","$0e112480d1414235$var$proxyCounter","isReleased","WeakMap","FinalizationRegistry","arr","processed","Array","prototype","concat","$0e112480d1414235$var$transferCache","transfers","handler","serializedValue","msg","fill","Math","floor","random","Number","MAX_SAFE_INTEGER","join","l","$b2637d91d9747a63$export$2c307b8f11fd7777","$dLq9J","$cfae44f0dfdf62c0$exports","$cfae44f0dfdf62c0$var$process","$cfae44f0dfdf62c0$var$defaultSetTimout","$cfae44f0dfdf62c0$var$defaultClearTimeout","$cfae44f0dfdf62c0$var$runTimeout","fun","setTimeout","clearTimeout","$cfae44f0dfdf62c0$var$queue","$cfae44f0dfdf62c0$var$draining","$cfae44f0dfdf62c0$var$queueIndex","$cfae44f0dfdf62c0$var$cleanUpNextTick","$cfae44f0dfdf62c0$var$drainQueue","timeout","len","run","$cfae44f0dfdf62c0$var$runClearTimeout","marker","$cfae44f0dfdf62c0$var$Item","array","$cfae44f0dfdf62c0$var$noop","nextTick","args","arguments","i","push","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","$abc9fcc4b1165aa9$exports","URL","url","$b9f4e619498c4711$var$Module","moduleArg","Module","reject","readyPromiseResolve","readyPromiseReject","readBinary","wasmBinary","wasmMemory","HEAP8","HEAPU8","HEAP16","HEAPU16","HEAP32","HEAPU32","HEAPF32","HEAPF64","wasmBinaryFile","embind_charCodes","BindingError","InternalError","wasmTable","UnboundTypeError","calledRun","baseErrorType","errorName","errorClass","moduleOverrides","ENVIRONMENT_IS_WEB","window","ENVIRONMENT_IS_WORKER","importScripts","node","scriptDirectory","self","location","href","document","currentScript","src","indexOf","substr","replace","lastIndexOf","xhr","XMLHttpRequest","open","responseType","send","Uint8Array","response","log","WebAssembly","abort","ABORT","updateMemoryViews","b","buffer","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","__ATPRERUN__","__ATINIT__","__ATPOSTRUN__","runDependencies","runDependencyWatcher","dependenciesFulfilled","what","RuntimeError","isDataURI","filename","startsWith","getBinarySync","file","instantiateArrayBuffer","binaryFile","imports","receiver","getBinaryPromise","fetch","credentials","binary","instantiate","instance","reason","callRuntimeCallbacks","callbacks","shift","ExceptionInfo","excPtr","ptr","set_type","get_type","set_destructor","destructor","get_destructor","set_caught","caught","get_caught","set_rethrown","rethrown","get_rethrown","set_adjusted_ptr","adjustedPtr","get_adjusted_ptr","get_exception_ptr","___cxa_is_pointer_type","adjusted","exceptionLast","uncaughtExceptionCount","readLatin1String","ret","c","awaitingDependencies","registeredTypes","typeDependencies","throwBindingError","throwInternalError","whenDependentTypesAreResolved","myTypes","dependentTypes","getTypeConverters","onComplete","typeConverters","myTypeConverters","registerType","forEach","unregisteredTypes","registered","dt","hasOwnProperty","rawType","registeredInstance","options","sharedRegisterType","ignoreDuplicateRegistrations","cb","HandleAllocator","allocated","freelist","emval_handles","__emval_decref","handle","reserved","refcount","free","Emval","toValue","toHandle","allocate","simpleReadValueFromPointer","pointer","floatReadValueFromPointer","width","createNamedFunction","body","runDestructors","destructors","pop","del","ensureOverloadTable","proto","methodName","humanName","overloadTable","prevFunc","argCount","exposePublicSymbol","numArguments","heap32VectorToArray","count","firstElement","replacePublicSymbol","dynCallLegacy","sig","f","wasmTableMirror","getWasmTableEntry","funcPtr","func","dynCall","includes","getDynCaller","argCache","embind__requireFunction","signature","rawFunction","fp","getTypeName","___getTypeName","rv","_free","throwUnboundTypeError","types","unboundTypes","seen","visit","getFunctionName","argsIndex","trim","integerReadValueFromPointer","signed","readPointer","stringToUTF8Array","str","heap","outIdx","maxBytesToWrite","startIdx","endIdx","u","charCodeAt","u1","stringToUTF8","outPtr","lengthBytesUTF8","UTF8Decoder","TextDecoder","UTF8ArrayToString","heapOrArray","idx","maxBytesToRead","endPtr","decode","subarray","u0","String","fromCharCode","u2","ch","UTF8ToString","UTF16Decoder","UTF16ToString","maxIdx","codeUnit","stringToUTF16","startPtr","numCharsToWrite","lengthBytesUTF16","UTF32ToString","utf32","stringToUTF32","trailSurrogate","lengthBytesUTF32","getHeapMax","growMemory","size","pages","byteLength","grow","embind_init_charCodes","codes","has","create","wasmImports","info","k","primitiveType","minRange","maxRange","trueValue","falseValue","wt","o","destructorFunction","h","d","g","rawArgTypesAddr","rawInvoker","fn","isAsync","argTypes","invokerArgsArray","craftInvokerFunction","classType","cppInvokerFunc","cppTargetFunc","isClassMethodFunc","needsDestructorStack","returns","argsList","argsListWired","invokerFnBody","dtorStack","args1","args2","paramName","invokerFn","newFunc","Function","dummy","fromWireType","bitshift","isUnsignedType","checkAssertions","toTypeName","a","dataTypeIndex","TA","typeMapping","decodeMemoryView","stdStringIsUTF8","payload","decodeStartPtr","currentBytePtr","maxRead","stringSegment","ArrayBuffer","valueIsOfTypeString","Uint8ClampedArray","base","_malloc","charCode","charSize","decodeString","encodeString","getHeap","lengthBytesUTF","HEAP","maxReadBytes","j","isVoid","m","dest","num","copyWithin","requestedSize","oldSize","maxHeapSize","alignUp","x","multiple","cutDown","overGrownHeapSize","min","max","wasmExports","createWasm","receiveInstance","unshift","removeRunDependency","clearInterval","instantiateAsync","result","instantiateStreaming","a0","preRun","addOnPreRun","doRun","postRun","addOnPostRun","runCaller","ready","$b6ad592ba86e0ced$export$6b0910223fe46ee7","bufferSize","initialPoolSize","pool","initPool","getBuffer","returnBuffer","vertexCount","globalBuffer","combinedLength","calculateCombinedLength","bufferPool","load","viewProjPtr","BYTES_PER_ELEMENT","globalBufferPtr","combinedPtr","runSort","viewProj","byteStart","bufferToTransfer","transfer","dispose","expose"],"version":3,"file":"worker.487a2036.js.map"}